{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Signalbot","text":"<p>Python package to build your own Signal bots.</p> <p>The package provides methods to easily listen for incoming messages and responding or reacting on them. It also provides a class to develop new commands, which then can be registered within the bot.</p> <p>Here is minimal example of what that looks like: <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom signalbot import (\n    Command,\n    Config,\n    Context,\n    SignalBot,\n    enable_console_logging,\n    triggered,\n)\n\n\nclass PingCommand(Command):\n    @triggered(\"Ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Pong\")\n\n\nif __name__ == \"__main__\":\n    enable_console_logging(logging.INFO)\n\n    bot = SignalBot(\n        Config(\n            signal_service=os.environ[\"SIGNAL_SERVICE\"],\n            phone_number=os.environ[\"PHONE_NUMBER\"],\n        )\n    )\n    bot.register(PingCommand())  # Run the command for all contacts and groups\n    bot.start()\n</code></pre></p> <p>To set it up follow the steps in the getting started page.</p>"},{"location":"#methods-overview","title":"Methods overview","text":"<p>The bot can do a lot more, here is a quick overview of the most common methods:</p> <ul> <li><code>bot.register(command, contacts=True, groups=True)</code>: Register a new command, listen in all contacts and groups, same as <code>bot.register(command)</code></li> <li><code>bot.register(command, contacts=False, groups=[\"Hello World\"])</code>: Only listen in the \"Hello World\" group</li> <li><code>bot.register(command, contacts=[\"+49123456789\"], groups=False)</code>: Only respond to one contact</li> <li><code>bot.start()</code>: Start the bot</li> <li><code>bot.send(receiver, text)</code>: Send a new message</li> <li><code>bot.react(message, emoji)</code>: React to a message</li> <li><code>bot.start_typing(receiver)</code>: Start typing</li> <li><code>bot.stop_typing(receiver)</code>: Stop typing</li> <li><code>bot.send(receiver, text, edit_timestamp=timestamp)</code>: Edit a previously sent message</li> <li><code>bot.remote_delete(receiver, timestamp)</code>: Delete a previously sent message</li> <li><code>bot.receipt(message, receipt_type)</code>: Mark a message as read</li> <li><code>bot.update_group(group_id, avatar, description, expiration, name)</code>: Change group settings</li> <li><code>bot.delete_attachment(attachment_filename)</code>: Delete the local copy of an attachment</li> <li><code>bot.scheduler</code>: Schedule tasks, see the scheduler examples.</li> </ul>"},{"location":"#real-world-bot-examples","title":"Real world bot examples","text":"<p>There are many real world examples of bot implementations using this library. Check the whole list at https://github.com/signalbot-org/signalbot/network/dependents</p>"},{"location":"additional_information/","title":"Additional information","text":""},{"location":"additional_information/#logging","title":"Logging","text":"<p>The logger name for the library is <code>\"signalbot\"</code>. It does not have any handlers attached, for convenience the <code>enable_console_logging(level)</code> function is provided.</p>"},{"location":"additional_information/#persistent-storage","title":"Persistent storage","text":"<p>By default the <code>bot.storage</code> is in-memory. Any changes are lost when the bot is stopped or reseted. For persistent storage to disk, check the SQLite or Redis storage in <code>storage.py</code>.</p>"},{"location":"api_bot/","title":"SignalBot","text":""},{"location":"api_bot/#signalbot.bot.SignalBot","title":"SignalBot","text":"<pre><code>SignalBot(config: Config | Mapping | Path | str)\n</code></pre> <p>SignalBot is the main class for the bot. It provides methods to register commands, start the bot, and interact with messages.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Config</code> <p>The configuration for the bot.</p> <code>commands</code> <code>CommandList</code> <p>A list of registered commands with their filters. Only available after <code>.start()</code> is called and <code>init_task</code> is done.</p> <code>groups</code> <code>list</code> <p>A list of groups the bot is a member of. Only available after <code>.start()</code> is called and <code>init_task</code> is done.</p> <code>storage</code> <code>SQLiteStorage | RedisStorage</code> <p>The storage backend used by the bot.</p> <code>scheduler</code> <code>AsyncIOScheduler</code> <p>The scheduler for running scheduled tasks.</p> <code>init_task</code> <code>None | Task</code> <p>The initialization async task for the bot. Only available after <code>.start()</code> is called.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | Mapping | Path | str</code> <p>the configuration for the bot.</p> required <p>Example config: <pre><code>{\n    signal_service: \"127.0.0.1:8080\",\n    phone_number: \"+49123456789\"\n}\n</code></pre></p> Source code in <code>src/signalbot/bot.py</code> <pre><code>def __init__(self, config: Config | Mapping | Path | str) -&gt; None:\n    \"\"\"Initilization for the SignalBot.\n\n    Args:\n        config: the configuration for the bot.\n\n    Example config:\n    ```python\n    {\n        signal_service: \"127.0.0.1:8080\",\n        phone_number: \"+49123456789\"\n    }\n    ```\n    \"\"\"\n    self._logger = logging.getLogger(LOGGER_NAME)\n\n    self.config = load_config(config)\n\n    self._commands_to_be_registered: CommandList = []  # populated by .register()\n    self.commands: CommandList = []  # populated by .start()\n\n    self.groups = []  # populated by .start()\n    self._groups_by_id = {}\n    self._groups_by_internal_id = {}\n    self._groups_by_name = defaultdict(list)\n\n    self.init_task: None | asyncio.Task = None\n\n    try:\n        self._signal = SignalAPI(\n            self.config.signal_service,\n            self.config.phone_number,\n            self.config.download_attachments,\n            self.config.connection_mode,\n        )\n    except KeyError:\n        raise SignalBotError(\"Could not initialize SignalAPI with given config\")  # noqa: B904, EM101, TRY003\n\n    try:\n        self._event_loop = asyncio.get_event_loop()\n    except RuntimeError:\n        self._event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._event_loop)\n\n    self._q = asyncio.Queue()\n\n    self._produce_tasks: set[asyncio.Task] = set()\n    self._consume_tasks: set[asyncio.Task] = set()\n\n    try:\n        self.scheduler = AsyncIOScheduler(event_loop=self._event_loop)\n    except Exception as e:  # noqa: BLE001\n        raise SignalBotError(f\"Could not initialize scheduler: {e}\")  # noqa: B904, EM102, TRY003\n\n    if isinstance(self.config.storage, SQLiteConfig):\n        self.storage = SQLiteStorage(\n            self.config.storage.sqlite_db,\n            check_same_thread=self.config.storage.check_same_thread,\n        )\n        self._logger.info(\"sqlite storage initilized\")\n    elif isinstance(self.config.storage, RedisConfig):\n        self.storage = RedisStorage(\n            self.config.storage.redis_host, self.config.storage.redis_port\n        )\n        self._logger.info(\"redis storage initilized\")\n    elif isinstance(self.config.storage, InMemoryConfig):\n        self.storage = SQLiteStorage()\n        self._logger.info(\"in-memory storage initilized\")\n    else:\n        self.storage = SQLiteStorage()\n        self._logger.warning(\n            \" Using in-memory storage.\"\n            \" Restarting will delete the storage!\"\n            \" Add storage: {'type': 'in-memory'}\"\n            \" to the config to silence this error.\",\n        )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.delete_attachment","title":"delete_attachment  <code>async</code>","text":"<pre><code>delete_attachment(attachment_filename: str) -&gt; None\n</code></pre> <p>Delete an attachment from local storage.</p> <p>Parameters:</p> Name Type Description Default <code>attachment_filename</code> <code>str</code> <p>File name to delete.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def delete_attachment(self, attachment_filename: str) -&gt; None:\n    \"\"\"Delete an attachment from local storage.\n\n    Args:\n        attachment_filename: File name to delete.\n    \"\"\"\n    await self._signal.delete_attachment(attachment_filename)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.react","title":"react  <code>async</code>","text":"<pre><code>react(message: Message, emoji: str) -&gt; None\n</code></pre> <p>React to a message with an emoji.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to react to.</p> required <code>emoji</code> <code>str</code> <p>Emoji reaction value.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def react(self, message: Message, emoji: str) -&gt; None:\n    \"\"\"React to a message with an emoji.\n\n    Args:\n        message: The message to react to.\n        emoji: Emoji reaction value.\n    \"\"\"\n    # TODO: check that emoji is really an emoji  # noqa: TD002, TD003\n    recipient = message.recipient()\n    recipient = self._resolve_receiver(recipient)\n    target_author = message.source\n    timestamp = message.timestamp\n    await self._signal.react(recipient, emoji, target_author, timestamp)\n    self._logger.info(f\"[Bot] New reaction: {emoji}\")  # noqa: G004\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.receipt","title":"receipt  <code>async</code>","text":"<pre><code>receipt(\n    message: Message,\n    receipt_type: Literal[\"read\", \"viewed\"],\n) -&gt; None\n</code></pre> <p>Send a read or viewed receipt for a message if supported.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to acknowledge.</p> required <code>receipt_type</code> <code>Literal['read', 'viewed']</code> <p>Receipt type to send.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def receipt(\n    self,\n    message: Message,\n    receipt_type: Literal[\"read\", \"viewed\"],\n) -&gt; None:\n    \"\"\"Send a read or viewed receipt for a message if supported.\n\n    Args:\n        message: The message to acknowledge.\n        receipt_type: Receipt type to send.\n    \"\"\"\n    if message.group is not None:\n        self._logger.warning(\"[Bot] Receipts are not supported for groups\")\n        return\n\n    recipient = self._resolve_receiver(message.recipient())\n    await self._signal.receipt(recipient, receipt_type, message.timestamp)\n    self._logger.info(f\"[Bot] Receipt: {receipt_type}\")  # noqa: G004\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.register","title":"register","text":"<pre><code>register(\n    command: Command,\n    contacts: list[str] | bool = True,\n    groups: list[str] | bool = True,\n    f: Callable[[Message], bool] | None = None,\n) -&gt; None\n</code></pre> <p>Register a command with optional contact/group filters.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>Command instance to register.</p> required <code>contacts</code> <code>list[str] | bool</code> <p>Allowed contacts or True for all.</p> <code>True</code> <code>groups</code> <code>list[str] | bool</code> <p>Allowed groups or True for all.</p> <code>True</code> <code>f</code> <code>Callable[[Message], bool] | None</code> <p>Optional function to further filter messages.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def register(\n    self,\n    command: Command,\n    contacts: list[str] | bool = True,  # noqa: FBT001, FBT002\n    groups: list[str] | bool = True,  # noqa: FBT001, FBT002\n    f: Callable[[Message], bool] | None = None,\n) -&gt; None:\n    \"\"\"Register a command with optional contact/group filters.\n\n    Args:\n        command: Command instance to register.\n        contacts: Allowed contacts or True for all.\n        groups: Allowed groups or True for all.\n        f: Optional function to further filter messages.\n    \"\"\"\n    command.bot = self\n    command.setup()\n    self._commands_to_be_registered.append((command, contacts, groups, f))\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.remote_delete","title":"remote_delete  <code>async</code>","text":"<pre><code>remote_delete(receiver: str, timestamp: int) -&gt; int\n</code></pre> <p>Delete a previously sent message.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Recipient identifier.</p> required <code>timestamp</code> <code>int</code> <p>Timestamp of the message to delete.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The timestamp of the delete action.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def remote_delete(self, receiver: str, timestamp: int) -&gt; int:\n    \"\"\"Delete a previously sent message.\n\n    Args:\n        receiver: Recipient identifier.\n        timestamp: Timestamp of the message to delete.\n\n    Returns:\n        The timestamp of the delete action.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n\n    resp = await self._signal.remote_delete(\n        receiver,\n        timestamp=timestamp,\n    )\n    resp_payload = await resp.json()\n    ret_timestamp = int(resp_payload[\"timestamp\"])\n    self._logger.info(f\"[Bot] Deleted message with timestamp {timestamp}\")  # noqa: G004\n\n    return ret_timestamp\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.send","title":"send  <code>async</code>","text":"<pre><code>send(\n    receiver: str,\n    text: str,\n    *,\n    base64_attachments: list | None = None,\n    link_preview: LinkPreview | None = None,\n    quote_author: str | None = None,\n    quote_mentions: list | None = None,\n    quote_message: str | None = None,\n    quote_timestamp: int | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    edit_timestamp: int | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int\n</code></pre> <p>Send or edit a message.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>The recipient of the message.</p> required <code>text</code> <code>str</code> <p>The content of the message.</p> required <code>base64_attachments</code> <code>list | None</code> <p>List of attachments encoded in base64.</p> <code>None</code> <code>link_preview</code> <code>LinkPreview | None</code> <p>Link previews to be sent with the message.</p> <code>None</code> <code>quote_author</code> <code>str | None</code> <p>The author of the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_mentions</code> <code>list | None</code> <p>List of mentioned users in the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_message</code> <code>str | None</code> <p>The content of the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_timestamp</code> <code>int | None</code> <p>The timestamp of the quoted message, required if quote_message is set.</p> <code>None</code> <code>mentions</code> <code>list[dict[str, Any]] | None</code> <p>List of dictionary of mentions, it has the format <code>[{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]</code>.</p> <code>None</code> <code>edit_timestamp</code> <code>int | None</code> <p>The timestamp of the message to edit, if not set a new message will be sent.</p> <code>None</code> <code>text_mode</code> <code>str | None</code> <p>The text mode of the message, can be \"normal\" or \"styled\".</p> <code>None</code> <code>view_once</code> <code>bool</code> <p>Whether the message should be view once or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>The timestamp of the sent or edited message.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def send(  # noqa: PLR0913\n    self,\n    receiver: str,\n    text: str,\n    *,\n    base64_attachments: list | None = None,\n    link_preview: LinkPreview | None = None,\n    quote_author: str | None = None,\n    quote_mentions: list | None = None,\n    quote_message: str | None = None,\n    quote_timestamp: int | None = None,\n    mentions: (\n        list[dict[str, Any]] | None\n    ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n    edit_timestamp: int | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Send or edit a message.\n\n    Args:\n        receiver: The recipient of the message.\n        text: The content of the message.\n        base64_attachments: List of attachments encoded in base64.\n        link_preview: Link previews to be sent with the message.\n        quote_author: The author of the quoted message, required if quote_message is\n            set.\n        quote_mentions: List of mentioned users in the quoted message, required if\n            quote_message is set.\n        quote_message: The content of the quoted message, required if quote_message\n            is set.\n        quote_timestamp: The timestamp of the quoted message, required if\n            quote_message is set.\n        mentions: List of dictionary of mentions, it has the format\n            `[{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]`.\n        edit_timestamp: The timestamp of the message to edit, if not set a new\n            message will be sent.\n        text_mode: The text mode of the message, can be \"normal\" or \"styled\".\n        view_once: Whether the message should be view once or not.\n\n    Returns:\n        The timestamp of the sent or edited message.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    link_preview_raw = link_preview.model_dump() if link_preview else None\n\n    resp = await self._signal.send(\n        receiver,\n        text,\n        base64_attachments=base64_attachments,\n        link_preview=link_preview_raw,\n        quote_author=quote_author,\n        quote_mentions=quote_mentions,\n        quote_message=quote_message,\n        quote_timestamp=quote_timestamp,\n        mentions=mentions,\n        text_mode=text_mode,\n        edit_timestamp=edit_timestamp,\n        view_once=view_once,\n    )\n    resp_payload = await resp.json()\n    timestamp = int(resp_payload[\"timestamp\"])\n    self._logger.info(f\"[Bot] New message {timestamp} sent:\\n{text}\")  # noqa: G004\n\n    return timestamp\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.signal_cli_rest_api_mode","title":"signal_cli_rest_api_mode  <code>async</code>","text":"<pre><code>signal_cli_rest_api_mode() -&gt; str\n</code></pre> <p>Return the signal-cli-rest-api mode.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def signal_cli_rest_api_mode(self) -&gt; str:\n    \"\"\"Return the signal-cli-rest-api mode.\"\"\"\n    return await self._signal.get_signal_cli_rest_api_mode()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.signal_cli_rest_api_version","title":"signal_cli_rest_api_version  <code>async</code>","text":"<pre><code>signal_cli_rest_api_version() -&gt; str\n</code></pre> <p>Return the signal-cli-rest-api version.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def signal_cli_rest_api_version(self) -&gt; str:\n    \"\"\"Return the signal-cli-rest-api version.\"\"\"\n    return await self._signal.get_signal_cli_rest_api_version()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.start","title":"start","text":"<pre><code>start(run_forever: bool = True) -&gt; None\n</code></pre> <p>Start the bot event loop and scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>run_forever</code> <code>bool</code> <p>Whether to start the event loop or only add the task to it.</p> <code>True</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def start(self, run_forever: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n    \"\"\"Start the bot event loop and scheduler.\n\n    Args:\n        run_forever: Whether to start the event loop or only add the task to it.\n    \"\"\"\n    self.init_task = self._event_loop.create_task(\n        self._rerun_on_exception(self._async_post_init),\n    )\n\n    if run_forever:\n        self.scheduler.start()\n\n        self._event_loop.run_forever()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.start_typing","title":"start_typing  <code>async</code>","text":"<pre><code>start_typing(receiver: str) -&gt; None\n</code></pre> <p>Send a typing indicator to a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Message recipient.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def start_typing(self, receiver: str) -&gt; None:\n    \"\"\"Send a typing indicator to a receiver.\n\n    Args:\n        receiver: Message recipient.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.start_typing(receiver)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.stop_typing","title":"stop_typing  <code>async</code>","text":"<pre><code>stop_typing(receiver: str) -&gt; None\n</code></pre> <p>Stop a typing indicator for a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Message recipient.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def stop_typing(self, receiver: str) -&gt; None:\n    \"\"\"Stop a typing indicator for a receiver.\n\n    Args:\n        receiver: Message recipient.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.stop_typing(receiver)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.update_contact","title":"update_contact  <code>async</code>","text":"<pre><code>update_contact(\n    receiver: str,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None\n</code></pre> <p>Update a contact's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Contact identifier.</p> required <code>expiration_in_seconds</code> <code>int | None</code> <p>Expiration timer in seconds.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Contact display name.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def update_contact(\n    self,\n    receiver: str,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Update a contact's metadata.\n\n    Args:\n        receiver: Contact identifier.\n        expiration_in_seconds: Expiration timer in seconds.\n        name: Contact display name.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.update_contact(\n        receiver,\n        expiration_in_seconds=expiration_in_seconds,\n        name=name,\n    )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.update_group","title":"update_group  <code>async</code>","text":"<pre><code>update_group(\n    group_id: str,\n    base64_avatar: str | None = None,\n    description: str | None = None,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None\n</code></pre> <p>Update a group's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Group identifier or name.</p> required <code>base64_avatar</code> <code>str | None</code> <p>Base64-encoded avatar.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Group description.</p> <code>None</code> <code>expiration_in_seconds</code> <code>int | None</code> <p>Expiration timer in seconds.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Group display name.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def update_group(\n    self,\n    group_id: str,\n    base64_avatar: str | None = None,\n    description: str | None = None,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Update a group's metadata.\n\n    Args:\n        group_id: Group identifier or name.\n        base64_avatar: Base64-encoded avatar.\n        description: Group description.\n        expiration_in_seconds: Expiration timer in seconds.\n        name: Group display name.\n    \"\"\"\n    group_id = self._resolve_receiver(group_id)\n    await self._signal.update_group(\n        group_id,\n        base64_avatar=base64_avatar,\n        description=description,\n        expiration_in_seconds=expiration_in_seconds,\n        name=name,\n    )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.enable_console_logging","title":"enable_console_logging","text":"<pre><code>enable_console_logging(level: int = WARNING) -&gt; None\n</code></pre> <p>Enable console logging for the signalbot logger.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level for the logger.</p> <code>WARNING</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def enable_console_logging(level: int = logging.WARNING) -&gt; None:\n    \"\"\"Enable console logging for the signalbot logger.\n\n    Args:\n        level: Logging level for the logger.\n    \"\"\"\n    handler = logging.StreamHandler()\n\n    formatter = logging.Formatter(\n        \"%(asctime)s %(name)s [%(levelname)s] - %(funcName)s - %(message)s\"\n    )\n    handler.setFormatter(formatter)\n\n    logger = logging.getLogger(LOGGER_NAME)\n    logger.addHandler(handler)\n    logger.setLevel(level)\n</code></pre>"},{"location":"api_bot_config/","title":"Config","text":""},{"location":"api_bot_config/#signalbot.bot_config.Config","title":"Config","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for SignalBot.</p> <p>Attributes:</p> Name Type Description <code>signal_service</code> <code>str</code> <p>The URL of the signal-cli-rest-api service to connect to.</p> <code>phone_number</code> <code>str</code> <p>The phone number of the bot.</p> <code>storage</code> <code>RedisConfig | SQLiteConfig | InMemoryConfig | None</code> <p>The configuration for the storage backend to use. Defaults to <code>None</code>.</p> <code>retry_interval</code> <code>int</code> <p>The interval in seconds to wait before retrying a failed connection to the signal service.</p> <code>download_attachments</code> <code>bool</code> <p>Whether to download attachments from messages. Defaults to <code>True</code>.</p> <code>connection_mode</code> <code>ConnectionMode</code> <p>The connection mode to use when connecting to the Signal service. Defaults to <code>ConnectionMode.AUTO</code>.</p> Source code in <code>src/signalbot/bot_config.py</code> <pre><code>class Config(BaseModel):\n    \"\"\"\n    The configuration for SignalBot.\n\n    Attributes:\n        signal_service: The URL of the signal-cli-rest-api service to connect to.\n        phone_number: The phone number of the bot.\n        storage: The configuration for the storage backend to use. Defaults to `None`.\n        retry_interval: The interval in seconds to wait before retrying a failed\n            connection to the signal service.\n        download_attachments: Whether to download attachments from messages. Defaults to\n            `True`.\n        connection_mode: The connection mode to use when connecting to the Signal\n            service. Defaults to `ConnectionMode.AUTO`.\n    \"\"\"\n\n    signal_service: str\n    phone_number: str\n\n    storage: RedisConfig | SQLiteConfig | InMemoryConfig | None = None\n    retry_interval: int = 1\n    download_attachments: bool = True\n    connection_mode: ConnectionMode = ConnectionMode.AUTO\n</code></pre>"},{"location":"api_bot_config/#signalbot.bot_config.InMemoryConfig","title":"InMemoryConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the in-memory storage backend.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['in-memory']</code> <p>The type of storage.</p> Source code in <code>src/signalbot/bot_config.py</code> <pre><code>class InMemoryConfig(BaseModel):\n    \"\"\"\n    The configuration for the in-memory storage backend.\n\n    Attributes:\n        type: The type of storage.\n    \"\"\"\n\n    type: Literal[\"in-memory\"] = \"in-memory\"\n</code></pre>"},{"location":"api_bot_config/#signalbot.bot_config.RedisConfig","title":"RedisConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the Redis storage backend.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['redis']</code> <p>The type of storage.</p> <code>redis_host</code> <code>str</code> <p>The hostname of the Redis server.</p> <code>redis_port</code> <code>int</code> <p>The port number of the Redis server.</p> Source code in <code>src/signalbot/bot_config.py</code> <pre><code>class RedisConfig(BaseModel):\n    \"\"\"\n    The configuration for the Redis storage backend.\n\n    Attributes:\n        type: The type of storage.\n        redis_host: The hostname of the Redis server.\n        redis_port: The port number of the Redis server.\n    \"\"\"\n\n    type: Literal[\"redis\"] = \"redis\"\n    redis_host: str\n    redis_port: int\n</code></pre>"},{"location":"api_bot_config/#signalbot.bot_config.SQLiteConfig","title":"SQLiteConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the SQLite storage backend.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['sqlite']</code> <p>The type of storage.</p> <code>sqlite_db</code> <code>str | Path</code> <p>The path to the SQLite database file.</p> <code>check_same_thread</code> <code>bool</code> <p>Whether to check the same thread when accessing the database.</p> Source code in <code>src/signalbot/bot_config.py</code> <pre><code>class SQLiteConfig(BaseModel):\n    \"\"\"\n    The configuration for the SQLite storage backend.\n\n    Attributes:\n        type: The type of storage.\n        sqlite_db: The path to the SQLite database file.\n        check_same_thread: Whether to check the same thread when accessing the database.\n    \"\"\"\n\n    type: Literal[\"sqlite\"] = \"sqlite\"\n    sqlite_db: str | Path\n    check_same_thread: bool = True\n</code></pre>"},{"location":"api_bot_config/#signalbot.api.ConnectionMode","title":"ConnectionMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Protocol strategy for connecting to signal-cli-rest-api.</p> <p>Attributes:</p> Name Type Description <code>HTTPS_ONLY</code> <p>Always use HTTPS/WSS.</p> <code>HTTP_ONLY</code> <p>Always use HTTP/WS.</p> <code>AUTO</code> <p>Start with HTTPS/WSS and fallback to HTTP/WS if unavailable.</p> Source code in <code>src/signalbot/api.py</code> <pre><code>class ConnectionMode(str, Enum):\n    \"\"\"Protocol strategy for connecting to signal-cli-rest-api.\n\n    Attributes:\n        HTTPS_ONLY: Always use HTTPS/WSS.\n        HTTP_ONLY: Always use HTTP/WS.\n        AUTO: Start with HTTPS/WSS and fallback to HTTP/WS if unavailable.\n    \"\"\"\n\n    HTTPS_ONLY = \"https_only\"\n    HTTP_ONLY = \"http_only\"\n    AUTO = \"auto\"\n</code></pre>"},{"location":"api_command/","title":"Command","text":""},{"location":"api_command/#signalbot.command.Command","title":"Command","text":"<pre><code>Command()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for commands.</p> <p>To create a command, subclass this class and implement the <code>handle</code> method. Then, register the command with the bot using <code>bot.register(CommandSubclass)</code>.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>def __init__(self) -&gt; None:\n    # The bot attribute is assigned after calling bot.register(Command())\n    self.bot: SignalBot | None = None\n</code></pre>"},{"location":"api_command/#signalbot.command.Command.handle","title":"handle  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle(context: Context) -&gt; None\n</code></pre> <p>Abstract method to handle a command. This method must be implemented by subclasses to define the behavior of the     command. Args:     context: Chat context containing the received message and other information.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>@abstractmethod\nasync def handle(self, context: Context) -&gt; None:\n    \"\"\"Abstract method to handle a command.\n    This method must be implemented by subclasses to define the behavior of the\n        command.\n    Args:\n        context: Chat context containing the received message and other information.\n    \"\"\"\n</code></pre>"},{"location":"api_command/#signalbot.command.Command.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Optional setup method that can be overridden by subclasses. This method is called after the command is registered with the bot but before any data is retrieved, so it cannot access the group ids.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Optional setup method that can be overridden by subclasses.\n    This method is called after the command is registered with the bot but\n    before any data is retrieved, so it cannot access the group ids.\n    \"\"\"\n    return\n</code></pre>"},{"location":"api_command/#signalbot.command.regex_triggered","title":"regex_triggered","text":"<pre><code>regex_triggered(\n    *by: str | Pattern[str],\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]\n</code></pre> <p>Decorator to trigger a command if the message text matches any of the provided regex patterns.</p> <p>Parameters:</p> Name Type Description Default <code>*by</code> <code>str | Pattern[str]</code> <p>A variable number of strings or compiled regex patterns to match the message text against.</p> <code>()</code> Source code in <code>src/signalbot/command.py</code> <pre><code>def regex_triggered(\n    *by: str | re.Pattern[str],\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"Decorator to trigger a command if the message text matches any of the provided\n    regex patterns.\n\n    Args:\n        *by: A variable number of strings or compiled regex patterns to match the\n            message text against.\n    \"\"\"\n\n    def decorator_regex_triggered(func: Callable[P, T]) -&gt; Callable[P, T]:\n        @functools.wraps(func)\n        async def wrapper_regex_triggered(\n            *args: P.args, **kwargs: P.kwargs\n        ) -&gt; T | None:\n            c: Context = args[1]\n            text = c.message.text\n            if not isinstance(text, str):\n                return None\n            matches = [bool(re.search(pattern, text)) for pattern in by]\n            if True not in matches:\n                return None\n            return await func(*args, **kwargs)\n\n        return wrapper_regex_triggered\n\n    return decorator_regex_triggered\n</code></pre>"},{"location":"api_command/#signalbot.command.triggered","title":"triggered","text":"<pre><code>triggered(\n    *by: str, case_sensitive: bool = False\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]\n</code></pre> <p>Decorator to trigger a command if the message text matches any of the provided strings.</p> <p>Parameters:</p> Name Type Description Default <code>*by</code> <code>str</code> <p>A variable number of strings to match the message text against.</p> <code>()</code> <code>case_sensitive</code> <code>bool</code> <p>Whether the matching should be case sensitive.</p> <code>False</code> Source code in <code>src/signalbot/command.py</code> <pre><code>def triggered(\n    *by: str, case_sensitive: bool = False\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"Decorator to trigger a command if the message text matches any of the provided\n    strings.\n\n    Args:\n        *by: A variable number of strings to match the message text against.\n        case_sensitive: Whether the matching should be case sensitive.\n    \"\"\"\n\n    def decorator_triggered(func: Callable[P, T]) -&gt; Callable[P, T]:\n        @functools.wraps(func)\n        async def wrapper_triggered(*args: P.args, **kwargs: P.kwargs) -&gt; T | None:\n            c: Context = args[1]\n            text = c.message.text\n            if not isinstance(text, str):\n                return None\n\n            by_words = by\n            if not case_sensitive:\n                text = text.lower()\n                by_words = [t.lower() for t in by_words]\n            if text not in by_words:\n                return None\n\n            return await func(*args, **kwargs)\n\n        return wrapper_triggered\n\n    return decorator_triggered\n</code></pre>"},{"location":"api_context/","title":"Context","text":""},{"location":"api_context/#signalbot.context.Context","title":"Context","text":"<pre><code>Context(bot: SignalBot, message: Message)\n</code></pre> <p>Context is a helper class that provides methods to reply, edit, react, etc. to a message. This is useful to avoid having to pass the recipient and other arguments to the bot's methods manually.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>def __init__(self, bot: SignalBot, message: Message) -&gt; None:\n    self.bot = bot\n    self.message = message\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(\n    text: str,\n    edit_timestamp: int,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int\n</code></pre> <p>Same as  signalbot.SignalBot.send() but with the recipient and timestamp set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def edit(  # noqa: PLR0913\n    self,\n    text: str,\n    edit_timestamp: int,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the recipient and timestamp set to the message's.\"\"\"\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        mentions=mentions,\n        text_mode=text_mode,\n        edit_timestamp=edit_timestamp,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.react","title":"react  <code>async</code>","text":"<pre><code>react(emoji: str) -&gt; None\n</code></pre> <p>Same as  signalbot.SignalBot.react() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def react(self, emoji: str) -&gt; None:\n    \"\"\"Same as\n     [signalbot.SignalBot.react()](api_bot.md#signalbot.SignalBot.react)\n    but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.react(self.message, emoji)\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.receipt","title":"receipt  <code>async</code>","text":"<pre><code>receipt(receipt_type: Literal['read', 'viewed']) -&gt; None\n</code></pre> <p>Same as  signalbot.SignalBot.receipt() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def receipt(self, receipt_type: Literal[\"read\", \"viewed\"]) -&gt; None:\n    \"\"\"Same as\n     [signalbot.SignalBot.receipt()](api_bot.md#signalbot.SignalBot.receipt)\n    but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.receipt(self.message, receipt_type)\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.remote_delete","title":"remote_delete  <code>async</code>","text":"<pre><code>remote_delete(timestamp: int) -&gt; int\n</code></pre> <p>Same as signalbot.SignalBot.remote_delete() but with the recipient and timestamp set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def remote_delete(self, timestamp: int) -&gt; int:\n    \"\"\"Same as\n    [signalbot.SignalBot.remote_delete()](api_bot.md#signalbot.SignalBot.remote_delete)\n    but with the recipient and timestamp set to the message's.\"\"\"\n    return await self.bot.remote_delete(\n        self.message.recipient(), timestamp=timestamp\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int\n</code></pre> <p>Same as  signalbot.SignalBot.send() but with the quote arguments set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def reply(  # noqa: PLR0913\n    self,\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: (\n        list[dict[str, Any]] | None\n    ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the quote arguments set to the message's.\"\"\"\n    send_mentions = self._convert_receive_mentions_into_send_mentions(\n        self.message.mentions,\n    )\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        quote_author=self.message.source,\n        quote_mentions=send_mentions,\n        quote_message=self.message.text,\n        quote_timestamp=self.message.timestamp,\n        mentions=mentions,\n        text_mode=text_mode,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.send","title":"send  <code>async</code>","text":"<pre><code>send(\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int\n</code></pre> <p>Same as  signalbot.SignalBot.send() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def send(  # noqa: PLR0913\n    self,\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the recipient set to the message's recipient.\"\"\"\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        mentions=mentions,\n        text_mode=text_mode,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.start_typing","title":"start_typing  <code>async</code>","text":"<pre><code>start_typing() -&gt; None\n</code></pre> <p>Same as signalbot.SignalBot.start_typing()  but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def start_typing(self) -&gt; None:\n    \"\"\"Same as\n    [signalbot.SignalBot.start_typing()](api_bot.md#signalbot.SignalBot.start_typing)\n     but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.start_typing(self.message.recipient())\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.stop_typing","title":"stop_typing  <code>async</code>","text":"<pre><code>stop_typing() -&gt; None\n</code></pre> <p>Same as signalbot.SignalBot.stop_typing()  but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def stop_typing(self) -&gt; None:\n    \"\"\"Same as\n    [signalbot.SignalBot.stop_typing()](api_bot.md#signalbot.SignalBot.stop_typing)\n     but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.stop_typing(self.message.recipient())\n</code></pre>"},{"location":"api_linkpreview/","title":"LinkPreview","text":""},{"location":"api_linkpreview/#signalbot.link_previews.LinkPreview","title":"LinkPreview","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass to representing a link preview.</p> <p>Attributes:</p> Name Type Description <code>base64_thumbnail</code> <code>str | None</code> <p>The base64 encoded thumbnail of the link preview, if available.</p> <code>title</code> <code>str</code> <p>The title of the link preview.</p> <code>description</code> <code>str | None</code> <p>The description of the link preview, if available.</p> <code>url</code> <code>str</code> <p>The url of the link preview.</p> <code>id</code> <code>str | None</code> <p>The local filename for a received link preview.</p> Source code in <code>src/signalbot/link_previews.py</code> <pre><code>class LinkPreview(BaseModel):\n    \"\"\"Dataclass to representing a link preview.\n\n    Attributes:\n        base64_thumbnail: The base64 encoded thumbnail of the link preview, if\n            available.\n        title: The title of the link preview.\n        description: The description of the link preview, if available.\n        url: The url of the link preview.\n        id: The local filename for a received link preview.\n    \"\"\"\n\n    base64_thumbnail: str | None\n    title: str\n    description: str | None\n    url: str\n    id: str | None = None\n</code></pre>"},{"location":"api_message/","title":"Message","text":""},{"location":"api_message/#signalbot.message.Message","title":"Message  <code>dataclass</code>","text":"<pre><code>Message(\n    source: str,\n    source_number: str | None,\n    source_uuid: str,\n    timestamp: int,\n    type: MessageType,\n    text: str,\n    base64_attachments: list[str] = list(),\n    attachments_local_filenames: list[str] = list(),\n    view_once: bool = False,\n    link_previews: list[LinkPreview] = list(),\n    group: str | None = None,\n    reaction: str | None = None,\n    mentions: list[str] = list(),\n    quote: Quote | None = None,\n    read_messages: list[dict] | None = None,\n    target_sent_timestamp: int | None = None,\n    remote_delete_timestamp: int | None = None,\n    updated_group_id: str | None = None,\n    raw_message: str | None = None,\n)\n</code></pre> <p>Class representing a Signal message.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>The phone number or UUID of the sender of the message.</p> <code>source_number</code> <code>str | None</code> <p>The phone number of the sender of the message. This is <code>None</code> for signal contacts where the phone number was not exchanged.</p> <code>source_uuid</code> <code>str</code> <p>The UUID of the sender of the message.</p> <code>timestamp</code> <code>int</code> <p>The timestamp of when the message was sent.</p> <code>type</code> <code>MessageType</code> <p>The type of the message.</p> <code>text</code> <code>str</code> <p>The text content of the message.</p> <code>base64_attachments</code> <code>list[str]</code> <p>A list of attachments in the message, encoded as base64 strings.</p> <code>attachments_local_filenames</code> <code>list[str]</code> <p>A list of local filenames for the attachments in the message.</p> <code>view_once</code> <code>bool</code> <p>A boolean indicating whether the message is a view-once message.</p> <code>link_previews</code> <code>list[LinkPreview]</code> <p>A list of <code>LinkPreview</code> objects representing the link previews in the message.</p> <code>group</code> <code>str | None</code> <p>The UUID of the group chat the message was sent in, or <code>None</code> if the message was sent in a user chat.</p> <code>reaction</code> <code>str | None</code> <p>The reaction emoji if the message is a reaction.</p> <code>mentions</code> <code>list[str]</code> <p>A list of UUIDs of users mentioned in the message.</p> <code>quote</code> <code>Quote | None</code> <p>An object representing the quoted message if the message is a quote.</p> <code>read_messages</code> <code>list[dict] | None</code> <p>A list of dictionaries representing the messages that have been read if the message is a <code>MessageType.READ_MESSAGE</code></p> <code>target_sent_timestamp</code> <code>int | None</code> <p>The timestamp of the original message that was edited, if the message is a <code>MessageType.EDIT_MESSAGE</code>.</p> <code>remote_delete_timestamp</code> <code>int | None</code> <p>The timestamp of the original message that was deleted, the message is a <code>MessageType.DELETE_MESSAGE</code>.</p> <code>updated_group_id</code> <code>str | None</code> <p>The UUID of the group that was updated, if the message is a <code>MessageType.GROUP_UPDATE_MESSAGE</code>.</p> <code>raw_message</code> <code>str | None</code> <p>The raw JSON string of the message as received from the Signal API.</p>"},{"location":"api_message/#signalbot.message.Message.is_group","title":"is_group","text":"<pre><code>is_group() -&gt; bool\n</code></pre> <p>Check if the message is a group message.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the message is a group message, False otherwise.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def is_group(self) -&gt; bool:\n    \"\"\"Check if the message is a group message.\n\n    Returns:\n        True if the message is a group message, False otherwise.\n    \"\"\"\n    return bool(self.group)\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.is_private","title":"is_private","text":"<pre><code>is_private() -&gt; bool\n</code></pre> <p>Check if the message is a private (one-on-one) message.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the message is a private (one-on-one) message, False otherwise.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def is_private(self) -&gt; bool:\n    \"\"\"Check if the message is a private (one-on-one) message.\n\n\n    Returns:\n        True if the message is a private (one-on-one) message, False otherwise.\n    \"\"\"\n    return not bool(self.group)\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.parse","title":"parse  <code>async</code> <code>classmethod</code>","text":"<pre><code>parse(signal: SignalAPI, raw_message_str: str) -&gt; Message\n</code></pre> <p>Parse a raw JSON message string from the Signal API into a Message object.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>SignalAPI</code> <p>An instance of the <code>SignalAPI</code> class, used to fetch attachments and link previews if necessary.</p> required <code>raw_message_str</code> <code>str</code> <p>The raw JSON string of the message as received from the Signal API.</p> required <p>Returns:</p> Type Description <code>Message</code> <p>A <code>Message</code> object representing the parsed message.</p> <p>Raises:</p> Type Description <code>UnknownMessageFormatError</code> <p>If the message format is unrecognized or if required fields are missing.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>@classmethod\nasync def parse(cls, signal: SignalAPI, raw_message_str: str) -&gt; Message:\n    \"\"\"Parse a raw JSON message string from the Signal API into a Message object.\n\n    Args:\n        signal: An instance of the `SignalAPI` class, used to fetch attachments and\n            link previews if necessary.\n        raw_message_str: The raw JSON string of the message as received from the\n            Signal API.\n\n    Returns:\n        A `Message` object representing the parsed message.\n\n    Raises:\n        UnknownMessageFormatError: If the message format is unrecognized or if\n            required fields are missing.\n    \"\"\"\n    try:\n        raw_message = json.loads(raw_message_str)\n    except Exception as exc:\n        raise UnknownMessageFormatError from exc\n\n    envelope = raw_message[\"envelope\"]\n    # General attributes\n    try:\n        source = envelope[\"source\"]\n        source_uuid = envelope[\"sourceUuid\"]\n        timestamp = envelope[\"timestamp\"]\n    except Exception as exc:\n        raise UnknownMessageFormatError from exc\n\n    source_number = envelope.get(\"sourceNumber\")\n\n    (\n        message_type,\n        data_message,\n        target_sent_timestamp,\n        remote_delete_timestamp,\n        updated_group_id,\n    ) = cls._extract_message_data(envelope)\n\n    text = cls._parse_data_message(data_message)\n    group = cls._parse_group_information(data_message)\n    reaction = cls._parse_reaction(data_message)\n    mentions = cls._parse_mentions(data_message)\n    quote = cls._parse_quote(data_message)\n    read_messages = data_message.get(\"readMessages\")\n\n    base64_attachments, attachments_local_filenames, link_previews = [], [], []\n    view_once = False\n    if signal.download_attachments:\n        base64_attachments = await cls._parse_attachments(signal, data_message)\n        attachments_local_filenames = cls._parse_attachments_local_filenames(\n            data_message,\n        )\n        link_previews = await cls._parse_previews(signal, data_message)\n        view_once = data_message.get(\"viewOnce\", False)\n\n    return cls(\n        source,\n        source_number,\n        source_uuid,\n        timestamp,\n        message_type,\n        text,\n        base64_attachments=base64_attachments,\n        attachments_local_filenames=attachments_local_filenames,\n        view_once=view_once,\n        link_previews=link_previews,\n        group=group,\n        reaction=reaction,\n        mentions=mentions,\n        quote=quote,\n        read_messages=read_messages,\n        target_sent_timestamp=target_sent_timestamp,\n        remote_delete_timestamp=remote_delete_timestamp,\n        updated_group_id=updated_group_id,\n        raw_message=raw_message_str,\n    )\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.recipient","title":"recipient","text":"<pre><code>recipient() -&gt; str\n</code></pre> <p>Get the recipient of the message, which is either the group ID for group     chats or the source ID for user chats.</p> <p>Returns:</p> Type Description <code>str</code> <p>The recipient ID of the message.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def recipient(self) -&gt; str:\n    \"\"\"Get the recipient of the message, which is either the group ID for group\n        chats or the source ID for user chats.\n\n    Returns:\n        The recipient ID of the message.\n    \"\"\"\n    # Case 1: Group chat\n    if self.group:\n        return self.group  # internal ID\n\n    # Case 2: User chat\n    return self.source\n</code></pre>"},{"location":"api_message/#signalbot.message.MessageType","title":"MessageType","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of a Signal message.</p> <p>Attributes:</p> Name Type Description <code>SYNC_MESSAGE</code> <p>Message received in a linked device</p> <code>DATA_MESSAGE</code> <p>Message received in a primary device</p> <code>EDIT_MESSAGE</code> <p>Message received is an edit of a previous message</p> <code>DELETE_MESSAGE</code> <p>Message received is a remote delete of a previous message</p> <code>READ_MESSAGE</code> <p>User read some messages</p> <code>GROUP_UPDATE_MESSAGE</code> <p>An update has been made to a group</p> <code>CONTACT_SYNC_MESSAGE</code> <p>Message received is a contact sync</p>"},{"location":"api_message/#signalbot.message.UnknownMessageFormatError","title":"UnknownMessageFormatError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a message with an unknown format is encountered.</p>"},{"location":"api_quote/","title":"Quote","text":""},{"location":"api_quote/#signalbot.quote.Quote","title":"Quote","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass to representing a quote.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the quoted message.</p> <code>author</code> <code>str</code> <p>The author of the quoted message.</p> <code>author_number</code> <code>str | None</code> <p>The phone number of the author of the quoted message, if available.</p> <code>author_uuid</code> <code>str</code> <p>The UUID of the author of the quoted message.</p> <code>text</code> <code>str</code> <p>The text of the quoted message.</p> <code>attachments</code> <code>list[dict[str, Any]]</code> <p>A list of attachments of the quoted message, if available.</p> Source code in <code>src/signalbot/quote.py</code> <pre><code>class Quote(BaseModel):\n    \"\"\"Dataclass to representing a quote.\n\n    Attributes:\n        id: The ID of the quoted message.\n        author: The author of the quoted message.\n        author_number: The phone number of the author of the quoted message, if\n            available.\n        author_uuid: The UUID of the author of the quoted message.\n        text: The text of the quoted message.\n        attachments: A list of attachments of the quoted message, if available.\n    \"\"\"\n\n    model_config = ConfigDict(alias_generator=to_camel)  # Support fields in camel case\n\n    id: int\n    author: str\n    author_number: str | None = None\n    author_uuid: str\n    text: str\n    attachments: list[dict[str, Any]]\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>Install it with <pre><code>pip install signalbot\n</code></pre></p> <p>Below you can find a minimal example on how to use the package. Save it as <code>bot.py</code>. There is also a bigger example in the examples section.</p> <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom signalbot import (\n    Command,\n    Config,\n    Context,\n    SignalBot,\n    enable_console_logging,\n    triggered,\n)\n\n\nclass PingCommand(Command):\n    @triggered(\"Ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Pong\")\n\n\nif __name__ == \"__main__\":\n    enable_console_logging(logging.INFO)\n\n    bot = SignalBot(\n        Config(\n            signal_service=os.environ[\"SIGNAL_SERVICE\"],\n            phone_number=os.environ[\"PHONE_NUMBER\"],\n        )\n    )\n    bot.register(PingCommand())  # Run the command for all contacts and groups\n    bot.start()\n</code></pre> <p>Please check out https://github.com/bbernhard/signal-cli-rest-api#getting-started to learn about signal-cli-rest-api and signal-cli. A good first step is to make the example above work.</p> <ol> <li> <p>Run signal-cli-rest-api in <code>normal</code> mode first. <pre><code>docker run -p 8080:8080 \\\n    -v $(pwd)/signal-cli-config:/home/.local/share/signal-cli \\\n    -e 'MODE=normal' bbernhard/signal-cli-rest-api:latest\n</code></pre></p> </li> <li> <p>Open http://127.0.0.1:8080/v1/qrcodelink?device_name=local to link your account with the signal-cli-rest-api server</p> </li> <li> <p>In your Signal app, open settings and scan the QR code. The server can now receive and send messages. The access key will be stored in <code>$(PWD)/signal-cli-config</code>.</p> </li> <li> <p>Restart the server in <code>json-rpc</code> mode. <pre><code>docker run -p 8080:8080 \\\n    -v $(pwd)/signal-cli-config:/home/.local/share/signal-cli \\\n    -e 'MODE=json-rpc' bbernhard/signal-cli-rest-api:latest\n</code></pre></p> </li> <li> <p>The logs should show something like this. You can also confirm that the server is running in the correct mode by visiting http://127.0.0.1:8080/v1/about. <pre><code>...\ntime=\"2022-03-07T13:02:22Z\" level=info msg=\"Found number +491234567890 and added it to jsonrpc2.yml\"\n...\ntime=\"2022-03-07T13:02:24Z\" level=info msg=\"Started Signal Messenger REST API\"\n</code></pre></p> </li> <li> <p>Install <code>signalbot</code> and start your python script. You need to pass following environment variables to make the example run:</p> </li> <li><code>SIGNAL_SERVICE</code>: Address of the signal service without protocol, e.g. <code>127.0.0.1:8080</code></li> <li><code>PHONE_NUMBER</code>: Phone number of the bot, e.g. <code>+49123456789</code></li> </ol> <pre><code>export SIGNAL_SERVICE=\"127.0.0.1:8080\"\nexport PHONE_NUMBER=\"+49123456789\"\npip install signalbot\npython bot.py\n</code></pre> <p>By default, <code>SignalBot</code> starts with <code>HTTPS/WSS</code> and can fallback to <code>HTTP/WS</code> if needed. Set <code>connection_mode</code> in the config to control behavior: - <code>ConnectionMode.HTTPS_ONLY</code>: only <code>HTTPS/WSS</code> - <code>ConnectionMode.HTTP_ONLY</code>: only <code>HTTP/WS</code> - <code>ConnectionMode.AUTO</code>: start with <code>HTTPS/WSS</code>, fallback to <code>HTTP/WS</code> (default)</p> <ol> <li> <p>The logs should indicate that one \"producer\" and three \"consumers\" have started. The producer checks for new messages sent to the linked account using a web socket connection. It creates a task for every registered command and the consumers work off the tasks. In case you are working with many blocking function calls, you may need to adjust the number of consumers such that the bot stays reactive. <pre><code>&lt;date&gt; signalbot [WARNING] - __init__ - [Bot] Could not initialize Redis and no SQLite DB name was given. In-memory storage will be used. Restarting will delete the storage! Add storage: {'type': 'in-memory'} to the config to silence this error.\n&lt;date&gt; signalbot [INFO] - _detect_groups - [Bot] 3 groups detected\n&lt;date&gt; signalbot [INFO] - _produce - [Bot] Producer #1 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #1 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #2 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #3 started\n</code></pre></p> </li> <li> <p>Send the message <code>Ping</code> (case sensitive) to the number that the bot is listening to. The bot (i.e. the linked account) should respond with a <code>Pong</code>. Confirm that the bot received a raw message, that the consumer worked on the message and that a new message has been sent. <pre><code>&lt;date&gt; signalbot [INFO] - _produce - [Raw Message] {\"envelope\": &lt;raw message dictionary&gt;}\n&lt;date&gt; signalbot [INFO] - _consume_new_item - [Bot] Consumer #2 got new job in 0.00046 seconds\n&lt;date&gt; signalbot [INFO] - _produce - [Raw Message] {\"envelope\": &lt;raw message dictionary&gt;}\n&lt;date&gt; signalbot [INFO] - send - [Bot] New message 1760797696983 sent:\nPong\n</code></pre></p> </li> </ol>"},{"location":"local_development/","title":"Contributing","text":"<p>Contributions are welcome.</p> <p>The first step to contribute is to install the package in editable mode. For any changes, check that the tests still pass as detailed below.</p>"},{"location":"local_development/#local-development","title":"Local development","text":"<ol> <li>Install uv.</li> <li>Create a venv and install signalbot with its dependencies in it     <pre><code>uv sync\n</code></pre></li> <li>Install the prek hook for linting and formatting     <pre><code>uv run prek install\n</code></pre></li> </ol>"},{"location":"local_development/#unit-testing","title":"Unit Testing","text":"<p>The tests can be executed with</p> <pre><code>uv run pytest\n</code></pre> <p>In many cases, we can mock receiving and sending messages to speed up development time. To do so, you can use <code>signalbot.utils.ChatTestCase</code> which sets up a \"skeleton\" bot. Then, you can send messages using the <code>@mock_chat</code> decorator in <code>signalbot.utils</code>. You can find an example implementation in <code>tests/test_chat.py</code>.</p>"},{"location":"local_development/#serving-the-documentation-locally","title":"Serving the documentation locally","text":"<ol> <li>Install the docs dependencies     <pre><code>uv sync --group docs\n</code></pre></li> <li>Run the mkdocs serve command     <pre><code>uv run mkdocs serve --livereload --watch ./\n</code></pre></li> </ol>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li>Check that you linked your account successfully</li> <li>Can you receive messages using <code>wscat</code> (websockets) and send messages using <code>curl</code> (http)?</li> <li>Do you see incoming messages in the API logs?</li> <li>Do you see the \"raw\" messages in the bot's logs?</li> <li>Do you see \"consumers\" picking up jobs and handling incoming messages?</li> <li>Do you see the response in the bot's logs?</li> </ul>"},{"location":"examples/api_overview/","title":"API overview","text":"<p>This bot showcases how to use most of the features in the library. Check the commands section to see the implementation of each command.</p> <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom commands import (\n    AttachmentCommand,\n    DeleteCommand,\n    DeleteLocalAttachmentCommand,\n    EditCommand,\n    HelpCommand,\n    PingCommand,\n    ReceiveDeleteCommand,\n    RegexTriggeredCommand,\n    ReplyCommand,\n    StylesCommand,\n    TriggeredCommand,\n    TypingCommand,\n)\n\nfrom signalbot import SignalBot, enable_console_logging\n\n\ndef main() -&gt; None:\n    enable_console_logging(logging.INFO)\n\n    signal_service = os.environ[\"SIGNAL_SERVICE\"]\n    phone_number = os.environ[\"PHONE_NUMBER\"]\n\n    config = {\n        \"signal_service\": signal_service,\n        \"phone_number\": phone_number,\n    }\n    bot = SignalBot(config)\n\n    bot.register(HelpCommand())\n\n    # enable a chat command for all contacts and all groups\n    bot.register(PingCommand())\n    bot.register(ReplyCommand())\n\n    # enable a chat command only for groups\n    bot.register(AttachmentCommand(), contacts=False, groups=True)\n\n    # enable a chat command for one specific group with the name \"My Group\"\n    bot.register(TypingCommand(), groups=[\"My Group\"])\n\n    # chat command is enabled for all groups and one specific contact\n    bot.register(TriggeredCommand(), contacts=[\"+490123456789\"], groups=True)\n\n    bot.register(RegexTriggeredCommand())\n\n    bot.register(EditCommand())\n    bot.register(DeleteCommand())\n    bot.register(ReceiveDeleteCommand())\n    bot.register(DeleteLocalAttachmentCommand())\n    bot.register(StylesCommand())\n    bot.start()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/api_overview/#commands","title":"Commands","text":"AttachmentCommand <pre><code>import base64\nfrom pathlib import Path\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass AttachmentCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"friday: \ud83e\udd80 Send and delete an image.\"\n\n    @triggered(\"friday\")\n    async def handle(self, c: Context) -&gt; None:\n        with open(Path(__file__).parent / \"image.jpeg\", \"rb\") as f:  # noqa: ASYNC230, PTH123\n            image = str(base64.b64encode(f.read()), encoding=\"utf-8\")\n\n        await c.send(\n            \"https://www.youtube.com/watch?v=pU2SdH1HBuk\",\n            base64_attachments=[image],\n        )\n</code></pre> DeleteCommand &amp; DeleteLocalAttachmentCommand &amp; ReceiveDeleteCommand <pre><code>import asyncio\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, MessageType, triggered\n\n\nclass DeleteCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"delete: \ud83d\uddd1\ufe0f Delete a message.\"\n\n    @triggered(\"delete\")\n    async def handle(self, c: Context) -&gt; None:\n        timestamp = await c.send(\"This message will be deleted in two seconds.\")\n        await asyncio.sleep(2)\n        await c.remote_delete(timestamp=timestamp)\n\n\nclass DeleteLocalAttachmentCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"delete_attachment: \ud83d\uddd1\ufe0f Delete the local copy of an attachment.\"\n\n    @triggered(\"delete_attachment\")\n    async def handle(self, c: Context) -&gt; None:\n        local_filenames = c.message.attachments_local_filenames\n        if local_filenames is None or len(local_filenames) == 0:\n            await c.send(\"Please send an attachment to delete.\")\n\n        for attachment_filename in local_filenames:\n            attachment_path: Path = (\n                Path.home()\n                / \".local/share/signal-api/attachments\"\n                / attachment_filename\n            )\n\n            if attachment_path.exists():\n                print(f\"Received file {attachment_path}\")  # noqa: T201\n\n            await c.bot.delete_attachment(attachment_filename)\n\n            if not attachment_path.exists():\n                print(f\"Deleted file {attachment_path}\")  # noqa: T201\n\n\nclass ReceiveDeleteCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"N/A: \ud83d\uddd1\ufe0f Receive a message has been deleted notification.\"\n\n    async def handle(self, c: Context) -&gt; None:\n        if c.message.type == MessageType.DELETE_MESSAGE:\n            deleted_at = datetime.fromtimestamp(  # noqa: DTZ006\n                c.message.remote_delete_timestamp / 1000\n            )\n            await c.send(f\"You've deleted a message, which was sent at {deleted_at}.\")\n</code></pre> EditCommand <pre><code>import asyncio\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass EditCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"edit: \u270f\ufe0f Edit a message.\"\n\n    @triggered(\"edit\")\n    async def handle(self, c: Context) -&gt; None:\n        timestamp = await c.send(\"This message will be edited in two seconds.\")\n        await asyncio.sleep(2)\n        await c.edit(\"This message has been edited.\", timestamp)\n</code></pre> HelpCommand <pre><code>from abc import abstractmethod\n\nfrom signalbot import Command, Context, triggered\n\n\nclass CommandWithHelpMessage(Command):\n    @abstractmethod\n    def help_message(self) -&gt; str:\n        pass\n\n\nclass HelpCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"help: \ud83c\udd98 Shows information about available commands.\"\n\n    @triggered(\"help\")\n    async def handle(self, c: Context) -&gt; None:\n        help_message = \"Available commands:\\n\"\n        command: CommandWithHelpMessage\n        for command, _, _, _ in self.bot.commands:\n            help_message += f\"\\t - {command.help_message()}\\n\"\n        await c.send(help_message)\n</code></pre> TriggeredCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass TriggeredCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"command_1, command_2 or command_3: \ud83d\ude24\ud83d\ude24\ud83d\ude24 Decorator example.\"\n\n    # add case_sensitive=True for case sensitive triggers\n    @triggered(\"command_1\", \"Command_2\", \"CoMmAnD_3\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"I am triggered\")\n</code></pre> PingCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass PingCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"ping: \ud83c\udfd3 Listen for a ping and send a pong reply.\"\n\n    @triggered(\"ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"pong\")\n</code></pre> RegexTriggeredCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, regex_triggered\n\n\nclass RegexTriggeredCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"^[\\\\w\\\\.-]+@gmail\\\\.com$: \ud83d\ude24 Regular expression decorator example.\"\n\n    @regex_triggered(r\"^[\\w\\.-]+@gmail\\.com$\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Detected a Gmail address!\")\n</code></pre> ReplyCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass ReplyCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"reply: \ud83d\udcac Reply to a message.\"\n\n    @triggered(\"reply\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.reply(\"This is a reply.\")\n</code></pre> StylesCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass StylesCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"styles: \ud83c\udfa8 Demonstrates different text styles.\"\n\n    @triggered(\"styles\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"**Bold style**\", text_mode=\"styled\")\n        await c.send(\"*Italic style*\", text_mode=\"styled\")\n        await c.send(\"~Strikethrough style~\", text_mode=\"styled\")\n        await c.send(\"||Spoiler style||\", text_mode=\"styled\")\n        await c.send(\"`Monospaced style`\", text_mode=\"styled\")\n</code></pre> TypingCommand <pre><code>import asyncio\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass TypingCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"typing: \u2328\ufe0f Demonstrates typing indicator for a few seconds.\"\n\n    @triggered(\"typing\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.start_typing()\n        seconds = 5\n        await asyncio.sleep(seconds)\n        await c.stop_typing()\n        await c.send(f\"Typed for {seconds}s\")\n</code></pre> <p>The code shown here can be found the example folder.</p>"},{"location":"examples/bot_config_options/","title":"Bot config","text":""},{"location":"examples/bot_config_options/#main-configuration","title":"Main configuration","text":"<p>The configuration of the bot can be specified in several ways.</p>"},{"location":"examples/bot_config_options/#config","title":"Config","text":"<p>Create a Config instance:</p> <pre><code>from signalbot import SignalBot, Config, ConnectionMode\n\nconfig = Config(\n    signal_service=\"http://localhost:8080\",\n    phone_number=\"+1234567890\",\n)\n\nbot = SignalBot(config)\nbot.start()\n</code></pre>"},{"location":"examples/bot_config_options/#dictionary","title":"Dictionary","text":"<p>Create a python dictionary:</p> <pre><code>from signalbot import SignalBot, Config\n\nconfig = {\n    \"signal_service\": \"http://localhost:8080\",\n    \"phone_number\": \"+1234567890\",\n}\n\nbot = SignalBot(config)\nbot.start()\n</code></pre>"},{"location":"examples/bot_config_options/#yaml-file","title":"Yaml file","text":"<p>Create a YAML configuration file:</p> config.yml<pre><code>signal_service: \"http://localhost:8080\"\nphone_number: \"+1234567890\"\n</code></pre> <p>Then load it:</p> <pre><code>from signalbot import SignalBot\n\nbot = SignalBot(\"config.yml\")\nbot.start()\n</code></pre>"},{"location":"examples/bot_config_options/#json-file","title":"Json file","text":"<p>Create a JSON configuration file:</p> config.json<pre><code>{\n    \"signal_service\": \"http://localhost:8080\",\n    \"phone_number\": \"+1234567890\",\n}\n</code></pre> <p>Then load it:</p> <pre><code>from signalbot import SignalBot\n\nbot = SignalBot(\"config.json\")\nbot.start()\n</code></pre>"},{"location":"examples/bot_config_options/#storage-type-options","title":"Storage type options","text":"<p>There are also several storage backends that can be used to handle data persistance.</p>"},{"location":"examples/bot_config_options/#in-memory","title":"In-memory","text":"<p>Stores data in memory only. Data is lost when the bot restarts. Useful for development and testing.</p> config.yml<pre><code>signal_service: \"http://localhost:8080\"\nphone_number: \"+1234567890\"\nstorage:\n    type: \"in-memory\"\n</code></pre>"},{"location":"examples/bot_config_options/#sqlite","title":"SQLite","text":"<p>Persists data to a local SQLite database.</p> config.yml<pre><code>signal_service: \"http://localhost:8080\"\nphone_number: \"+1234567890\"\nstorage:\n    type: \"sqlite\"\n    sqlite_db: \"./data/bot.db\"\n</code></pre>"},{"location":"examples/bot_config_options/#redis","title":"Redis","text":"<p>Persists data to Redis database.</p> config.yml<pre><code>signal_service: \"http://localhost:8080\"\nphone_number: \"+1234567890\"\nstorage:\n    type: \"redis\"\n    redis_host: \"localhost\"\n    redis_port: 6379\n</code></pre>"},{"location":"examples/bot_with_scheduler/","title":"Scheduler","text":"<p>This bot showcases how to use the scheduler and also how to use the library without using the Command class. <pre><code>import logging  # noqa: INP001\nimport os\n\ntry:\n    import typer\nexcept ImportError as exc:\n    error_msg = \"The 'typer' library is required to run this example.\"\n    error_msg += \" Please install it with 'pip install typer'.\"\n    raise ImportError(error_msg) from exc\n\nfrom signalbot import SignalBot, enable_console_logging\n\n\nasync def send(bot: SignalBot, receiver: str, text: str) -&gt; None:\n    # Wait until the bot is fully initialized before sending a message\n    await bot.init_task\n\n    await bot.send(receiver=receiver, text=text)\n\n\ndef main(\n    receiver: str = os.environ[\"PHONE_NUMBER\"],\n    text: str = \"Hello from SignalBot!\",\n) -&gt; None:\n    enable_console_logging(logging.INFO)\n\n    config = {\n        \"signal_service\": os.environ[\"SIGNAL_SERVICE\"],\n        \"phone_number\": os.environ[\"PHONE_NUMBER\"],\n    }\n    bot = SignalBot(config)\n\n    bot.scheduler.add_job(send, args=[bot, receiver, text])\n    bot.scheduler.add_job(\n        send, args=[bot, receiver, \"Ping\"], trigger=\"interval\", seconds=5\n    )\n    bot.start()\n\n\nif __name__ == \"__main__\":\n    typer.run(main)\n</code></pre></p>"}]}