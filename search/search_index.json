{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Signalbot","text":"<p>Python package to build your own Signal bots.</p> <p>The package provides methods to easily listen for incoming messages and responding or reacting on them. It also provides a class to develop new commands, which then can be registered within the bot.</p> <p>Here is minimal example of what that looks like: <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom signalbot import Command, Context, SignalBot, enable_console_logging, triggered\n\n\nclass PingCommand(Command):\n    @triggered(\"Ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Pong\")\n\n\nif __name__ == \"__main__\":\n    enable_console_logging(logging.INFO)\n\n    bot = SignalBot(\n        {\n            \"signal_service\": os.environ[\"SIGNAL_SERVICE\"],\n            \"phone_number\": os.environ[\"PHONE_NUMBER\"],\n        }\n    )\n    bot.register(PingCommand())  # Run the command for all contacts and groups\n    bot.start()\n</code></pre></p> <p>To set it up follow the steps in the getting started page.</p>"},{"location":"#methods-overview","title":"Methods overview","text":"<p>The bot can do a lot more, here is a quick overview of the most common methods:</p> <ul> <li><code>bot.register(command, contacts=True, groups=True)</code>: Register a new command, listen in all contacts and groups, same as <code>bot.register(command)</code></li> <li><code>bot.register(command, contacts=False, groups=[\"Hello World\"])</code>: Only listen in the \"Hello World\" group</li> <li><code>bot.register(command, contacts=[\"+49123456789\"], groups=False)</code>: Only respond to one contact</li> <li><code>bot.start()</code>: Start the bot</li> <li><code>bot.send(receiver, text)</code>: Send a new message</li> <li><code>bot.react(message, emoji)</code>: React to a message</li> <li><code>bot.start_typing(receiver)</code>: Start typing</li> <li><code>bot.stop_typing(receiver)</code>: Stop typing</li> <li><code>bot.send(receiver, text, edit_timestamp=timestamp)</code>: Edit a previously sent message</li> <li><code>bot.remote_delete(receiver, timestamp)</code>: Delete a previously sent message</li> <li><code>bot.receipt(message, receipt_type)</code>: Mark a message as read</li> <li><code>bot.update_group(group_id, avatar, description, expiration, name)</code>: Change group settings</li> <li><code>bot.delete_attachment(attachment_filename)</code>: Delete the local copy of an attachment</li> <li><code>bot.scheduler</code>: APScheduler &gt; AsyncIOScheduler, see here</li> </ul>"},{"location":"#real-world-bot-examples","title":"Real world bot examples","text":"<p>There are many real world examples of bot implementations using this library. Check the whole list at https://github.com/signalbot-org/signalbot/network/dependents</p>"},{"location":"additional_information/","title":"Additional information","text":""},{"location":"additional_information/#logging","title":"Logging","text":"<p>The logger name for the library is <code>\"signalbot\"</code>. It does not have any handlers attached, for convenience the <code>enable_console_logging(level)</code> function is provided.</p>"},{"location":"additional_information/#persistent-storage","title":"Persistent storage","text":"<p>By default the <code>bot.storage</code> is in-memory. Any changes are lost when the bot is stopped or reseted. For persistent storage to disk, check the SQLite or Redis storage in <code>storage.py</code>.</p>"},{"location":"api_bot/","title":"SignalBot","text":""},{"location":"api_bot/#signalbot.bot.SignalBot","title":"<code>SignalBot</code>","text":"<p>SignalBot is the main class for the bot. It provides methods to register commands, start the bot, and interact with messages.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>The configuration dictionary for the bot.</p> <code>commands</code> <code>CommandList</code> <p>A list of registered commands with their filters.</p> <code>groups</code> <code>list</code> <p>A list of groups the bot is a member of.</p> <code>storage</code> <code>SQLiteStorage | RedisStorage</code> <p>The storage backend used by the bot.</p> <code>scheduler</code> <code>AsyncIOScheduler</code> <p>The scheduler for running scheduled tasks.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>class SignalBot:\n    \"\"\"\n    SignalBot is the main class for the bot. It provides methods to register commands,\n    start the bot, and interact with messages.\n\n    Attributes:\n        config (dict): The configuration dictionary for the bot.\n        commands: A list of registered commands with their filters.\n        groups (list): A list of groups the bot is a member of.\n        storage (SQLiteStorage | RedisStorage): The storage backend used by the bot.\n        scheduler (AsyncIOScheduler): The scheduler for running scheduled tasks.\n    \"\"\"\n\n    def __init__(self, config: dict) -&gt; None:\n        \"\"\"Initilization for the SignalBot.\n\n        Args:\n            config: Dictionary with the bot configuration.\n\n        Example config:\n        ```yaml\n        # ======= Mandatory fields ========\n        signal_service: \"127.0.0.1:8080\"\n        phone_number: \"+49123456789\"\n\n        # ======= Optional fields ========\n        storage:\n            redis_host: \"redis\"\n            redis_port: 6379\n        retry_interval: 1\n        download_attachments: True\n        ```\n        \"\"\"\n        self._logger = logging.getLogger(LOGGER_NAME)\n\n        self.config = config\n\n        self._commands_to_be_registered: CommandList = []  # populated by .register()\n        self.commands: CommandList = []  # populated by .start()\n\n        self.groups = []  # populated by .start()\n        self._groups_by_id = {}\n        self._groups_by_internal_id = {}\n        self._groups_by_name = defaultdict(list)\n\n        try:\n            self._phone_number = self.config[\"phone_number\"]\n            self._signal_service = self.config[\"signal_service\"]\n            download_attachments = self.config.get(\"download_attachments\", True)\n            self._signal = SignalAPI(\n                self._signal_service,\n                self._phone_number,\n                download_attachments,\n            )\n        except KeyError:\n            raise SignalBotError(\"Could not initialize SignalAPI with given config\")  # noqa: B904, EM101, TRY003\n\n        try:\n            self._event_loop = asyncio.get_event_loop()\n        except RuntimeError:\n            self._event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self._event_loop)\n\n        self._q = asyncio.Queue()\n        self._running_tasks: set[asyncio.Task] = set()\n\n        self._produce_tasks: set[asyncio.Task] = set()\n        self._consume_tasks: set[asyncio.Task] = set()\n\n        try:\n            self.scheduler = AsyncIOScheduler(event_loop=self._event_loop)\n        except Exception as e:  # noqa: BLE001\n            raise SignalBotError(f\"Could not initialize scheduler: {e}\")  # noqa: B904, EM102, TRY003\n\n        config_storage = {}\n        try:\n            config_storage = self.config[\"storage\"]\n            if config_storage.get(\"type\") == \"sqlite\":\n                self._sqlite_db = config_storage[\"sqlite_db\"]\n                check_same_thread = config_storage.get(\"check_same_thread\", True)\n                self.storage = SQLiteStorage(\n                    self._sqlite_db,\n                    check_same_thread=check_same_thread,\n                )\n                self._logger.info(\"sqlite storage initilized\")\n            else:\n                self._redis_host = config_storage[\"redis_host\"]\n                self._redis_port = config_storage[\"redis_port\"]\n                self.storage = RedisStorage(self._redis_host, self._redis_port)\n                self._logger.info(\"redis storage initilized\")\n        except Exception:  # noqa: BLE001\n            self.storage = SQLiteStorage()\n            if config_storage.get(\"type\") != \"in-memory\":\n                self._logger.warning(\n                    \"[Bot] Could not initialize Redis and no SQLite DB name was given.\"\n                    \" In-memory storage will be used.\"\n                    \" Restarting will delete the storage!\"\n                    \" Add storage: {'type': 'in-memory'}\"\n                    \" to the config to silence this error.\",\n                )\n            if \"redis_host\" in config_storage:\n                self._logger.warning(\n                    f\"[Bot] Redis initialization error: {traceback.format_exc()}\",  # noqa: G004\n                )\n\n    def register(\n        self,\n        command: Command,\n        contacts: list[str] | bool = True,  # noqa: FBT001, FBT002\n        groups: list[str] | bool = True,  # noqa: FBT001, FBT002\n        f: Callable[[Message], bool] | None = None,\n    ) -&gt; None:\n        \"\"\"Register a command with optional contact/group filters.\n\n        Args:\n            command: Command instance to register.\n            contacts: Allowed contacts or True for all.\n            groups: Allowed groups or True for all.\n            f: Optional function to further filter messages.\n        \"\"\"\n        command.bot = self\n        command.setup()\n        self._commands_to_be_registered.append((command, contacts, groups, f))\n\n    async def _resolve_commands(self) -&gt; None:\n        self.commands = []\n        for command, contacts, groups, f in self._commands_to_be_registered:\n            group_ids = None\n\n            if isinstance(groups, bool):\n                group_ids = groups\n\n            if isinstance(groups, list):\n                group_ids = []\n                for group in groups:\n                    group_id = self._resolve_group_receiver(group)\n                    if group_id is not None:\n                        group_ids.append(group_id)\n                    else:\n                        error_msg = f\"[Bot] [{command.__class__.__name__}] '{group}' \"\n                        error_msg += \"is not a valid group name or id\"\n                        self._logger.warning(error_msg)\n\n            self.commands.append((command, contacts, group_ids, f))\n\n    async def _async_post_init(self) -&gt; None:\n        await self._check_signal_service()\n        await self._check_signal_cli_rest_api_version()\n        await self._check_signal_cli_rest_api_mode()\n        await self._detect_groups()\n        await self._resolve_commands()\n        await self._produce_consume_messages()\n\n    async def _check_signal_service(self) -&gt; None:\n        while (await self._signal.check_signal_service()) is False:\n            self._logger.error(\n                \"Cannot connect to the signal-cli-rest-api service, retrying\"\n            )\n            await asyncio.sleep(self.config.get(\"retry_interval\", 1))\n\n    async def _check_signal_cli_rest_api_version(self) -&gt; None:\n        min_version = Version(\"0.95.0\")\n        version = await self.signal_cli_rest_api_version()\n        if Version(version) &lt; min_version:\n            error_msg = f\"Incompatible signal-cli-rest-api version, found {version}\"\n            error_msg += f\", minimum required is {min_version}\"\n            raise RuntimeError(error_msg)\n\n    async def _check_signal_cli_rest_api_mode(self) -&gt; None:\n        mode = await self.signal_cli_rest_api_mode()\n        if mode != \"json-rpc\":\n            error_msg = (\n                f\"Wrong signal-cli-rest-api mode, found '{mode}', expected 'json-rpc'\"\n            )\n            raise RuntimeError(error_msg)\n\n    def _store_reference_to_task(\n        self,\n        task: asyncio.Task,\n        task_set: set[asyncio.Task],\n    ) -&gt; None:\n        # Keep a hard reference to the tasks, fixes Ruff's RUF006 rule\n        task_set.add(task)\n        task.add_done_callback(task_set.discard)\n\n    def start(self, run_forever: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n        \"\"\"Start the bot event loop and scheduler.\n\n        Args:\n            run_forever: Whether to start the event loop or only add the task to it.\n        \"\"\"\n        task = self._event_loop.create_task(\n            self._rerun_on_exception(self._async_post_init),\n        )\n        self._store_reference_to_task(task, self._running_tasks)\n\n        if run_forever:\n            self.scheduler.start()\n\n            self._event_loop.run_forever()\n\n    async def signal_cli_rest_api_version(self) -&gt; str:\n        \"\"\"Return the signal-cli-rest-api version.\"\"\"\n        return await self._signal.get_signal_cli_rest_api_version()\n\n    async def signal_cli_rest_api_mode(self) -&gt; str:\n        \"\"\"Return the signal-cli-rest-api mode.\"\"\"\n        return await self._signal.get_signal_cli_rest_api_mode()\n\n    async def send(  # noqa: PLR0913\n        self,\n        receiver: str,\n        text: str,\n        *,\n        base64_attachments: list | None = None,\n        link_preview: LinkPreview | None = None,\n        quote_author: str | None = None,\n        quote_mentions: list | None = None,\n        quote_message: str | None = None,\n        quote_timestamp: int | None = None,\n        mentions: (\n            list[dict[str, Any]] | None\n        ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n        edit_timestamp: int | None = None,\n        text_mode: str | None = None,\n        view_once: bool = False,\n    ) -&gt; int:\n        \"\"\"Send or edit a message.\n\n        Args:\n            receiver: The recipient of the message.\n            text: The content of the message.\n            base64_attachments: List of attachments encoded in base64.\n            link_preview: Link previews to be sent with the message.\n            quote_author: The author of the quoted message, required if quote_message is\n                set.\n            quote_mentions: List of mentioned users in the quoted message, required if\n                quote_message is set.\n            quote_message: The content of the quoted message, required if quote_message\n                is set.\n            quote_timestamp: The timestamp of the quoted message, required if\n                quote_message is set.\n            mentions: List of dictionary of mentions, it has the format\n                `[{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]`.\n            edit_timestamp: The timestamp of the message to edit, if not set a new\n                message will be sent.\n            text_mode: The text mode of the message, can be \"normal\" or \"styled\".\n            view_once: Whether the message should be view once or not.\n\n        Returns:\n            The timestamp of the sent or edited message.\n        \"\"\"\n        receiver = self._resolve_receiver(receiver)\n        link_preview_raw = link_preview.model_dump() if link_preview else None\n\n        resp = await self._signal.send(\n            receiver,\n            text,\n            base64_attachments=base64_attachments,\n            link_preview=link_preview_raw,\n            quote_author=quote_author,\n            quote_mentions=quote_mentions,\n            quote_message=quote_message,\n            quote_timestamp=quote_timestamp,\n            mentions=mentions,\n            text_mode=text_mode,\n            edit_timestamp=edit_timestamp,\n            view_once=view_once,\n        )\n        resp_payload = await resp.json()\n        timestamp = int(resp_payload[\"timestamp\"])\n        self._logger.info(f\"[Bot] New message {timestamp} sent:\\n{text}\")  # noqa: G004\n\n        return timestamp\n\n    async def react(self, message: Message, emoji: str) -&gt; None:\n        \"\"\"React to a message with an emoji.\n\n        Args:\n            message: The message to react to.\n            emoji: Emoji reaction value.\n        \"\"\"\n        # TODO: check that emoji is really an emoji  # noqa: TD002, TD003\n        recipient = message.recipient()\n        recipient = self._resolve_receiver(recipient)\n        target_author = message.source\n        timestamp = message.timestamp\n        await self._signal.react(recipient, emoji, target_author, timestamp)\n        self._logger.info(f\"[Bot] New reaction: {emoji}\")  # noqa: G004\n\n    async def receipt(\n        self,\n        message: Message,\n        receipt_type: Literal[\"read\", \"viewed\"],\n    ) -&gt; None:\n        \"\"\"Send a read or viewed receipt for a message if supported.\n\n        Args:\n            message: The message to acknowledge.\n            receipt_type: Receipt type to send.\n        \"\"\"\n        if message.group is not None:\n            self._logger.warning(\"[Bot] Receipts are not supported for groups\")\n            return\n\n        recipient = self._resolve_receiver(message.recipient())\n        await self._signal.receipt(recipient, receipt_type, message.timestamp)\n        self._logger.info(f\"[Bot] Receipt: {receipt_type}\")  # noqa: G004\n\n    async def start_typing(self, receiver: str) -&gt; None:\n        \"\"\"Send a typing indicator to a receiver.\n\n        Args:\n            receiver: Message recipient.\n        \"\"\"\n        receiver = self._resolve_receiver(receiver)\n        await self._signal.start_typing(receiver)\n\n    async def stop_typing(self, receiver: str) -&gt; None:\n        \"\"\"Stop a typing indicator for a receiver.\n\n        Args:\n            receiver: Message recipient.\n        \"\"\"\n        receiver = self._resolve_receiver(receiver)\n        await self._signal.stop_typing(receiver)\n\n    async def update_contact(\n        self,\n        receiver: str,\n        expiration_in_seconds: int | None = None,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Update a contact's metadata.\n\n        Args:\n            receiver: Contact identifier.\n            expiration_in_seconds: Expiration timer in seconds.\n            name: Contact display name.\n        \"\"\"\n        receiver = self._resolve_receiver(receiver)\n        await self._signal.update_contact(\n            receiver,\n            expiration_in_seconds=expiration_in_seconds,\n            name=name,\n        )\n\n    async def update_group(\n        self,\n        group_id: str,\n        base64_avatar: str | None = None,\n        description: str | None = None,\n        expiration_in_seconds: int | None = None,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Update a group's metadata.\n\n        Args:\n            group_id: Group identifier or name.\n            base64_avatar: Base64-encoded avatar.\n            description: Group description.\n            expiration_in_seconds: Expiration timer in seconds.\n            name: Group display name.\n        \"\"\"\n        group_id = self._resolve_receiver(group_id)\n        await self._signal.update_group(\n            group_id,\n            base64_avatar=base64_avatar,\n            description=description,\n            expiration_in_seconds=expiration_in_seconds,\n            name=name,\n        )\n\n    async def remote_delete(self, receiver: str, timestamp: int) -&gt; int:\n        \"\"\"Delete a previously sent message.\n\n        Args:\n            receiver: Recipient identifier.\n            timestamp: Timestamp of the message to delete.\n\n        Returns:\n            The timestamp of the delete action.\n        \"\"\"\n        receiver = self._resolve_receiver(receiver)\n\n        resp = await self._signal.remote_delete(\n            receiver,\n            timestamp=timestamp,\n        )\n        resp_payload = await resp.json()\n        ret_timestamp = int(resp_payload[\"timestamp\"])\n        self._logger.info(f\"[Bot] Deleted message with timestamp {timestamp}\")  # noqa: G004\n\n        return ret_timestamp\n\n    async def delete_attachment(self, attachment_filename: str) -&gt; None:\n        \"\"\"Delete an attachment from local storage.\n\n        Args:\n            attachment_filename: File name to delete.\n        \"\"\"\n        await self._signal.delete_attachment(attachment_filename)\n\n    async def _detect_groups(self) -&gt; None:\n        # reset group lookups to avoid stale data\n        self.groups = await self._signal.get_groups()\n\n        self._groups_by_id: dict[str, dict[str, Any]] = {}\n        self._groups_by_internal_id: dict[str, dict[str, Any]] = {}\n        self._groups_by_name: defaultdict[str, list[dict[str, Any]]] = defaultdict(list)\n        for group in self.groups:\n            self._groups_by_id[group[\"id\"]] = group\n            self._groups_by_internal_id[group[\"internal_id\"]] = group\n            self._groups_by_name[group[\"name\"]].append(group)\n\n        self._logger.info(f\"[Bot] {len(self.groups)} groups detected\")  # noqa: G004\n\n    async def _update_group(self, group_internal_id: str) -&gt; None:\n        # look up group that requires update\n        group = await self._signal.get_group(\n            self._groups_by_internal_id[group_internal_id][\"id\"]\n        )\n\n        current_group_name = self._groups_by_internal_id[group_internal_id][\n            \"name\"\n        ]  # group name may have been updated\n        self._groups_by_name[current_group_name] = [\n            g\n            for g in self._groups_by_name[current_group_name]\n            if g[\"id\"] != group[\"id\"]\n        ]\n        self.groups = [\n            group if g[\"internal_id\"] == group_internal_id else g for g in self.groups\n        ]\n        self._groups_by_id[group[\"id\"]] = group\n        self._groups_by_internal_id[group[\"internal_id\"]] = group\n        self._groups_by_name[group[\"name\"]].append(group)\n\n        self._logger.info(\"[Bot] Group updated\")\n\n    async def _process_updates(self, message: Message) -&gt; None:\n        # Update groups if message is from an unknown group\n        if (\n            message.is_group()\n            and self._groups_by_internal_id.get(message.group) is None\n        ):\n            await self._detect_groups()\n\n        if message.type == MessageType.GROUP_UPDATE_MESSAGE:\n            await self._update_group(message.updated_group_id)\n\n    def _resolve_receiver(self, receiver: str) -&gt; str:\n        if self._is_phone_number(receiver):\n            return receiver\n\n        if self._is_valid_uuid(receiver):\n            return receiver\n\n        if self._is_username(receiver):\n            return receiver\n\n        group_id = self._resolve_group_receiver(receiver)\n        if group_id is not None:\n            return group_id\n\n        raise SignalBotError(\"Cannot resolve receiver.\")  # noqa: EM101, TRY003\n\n    def _resolve_group_receiver(self, group_id_or_name: str) -&gt; str | None:\n        group = self._groups_by_id.get(group_id_or_name)\n        if group is not None:\n            return group[\"id\"]\n\n        if self._is_group_id(group_id_or_name):\n            error_msg = f\"[Bot] Group with id '{group_id_or_name}' not found. There \"\n            error_msg += \"is a typo in id or the bot is not a member of the group.\"\n            self._logger.warning(error_msg)\n            return group_id_or_name\n\n        group = self._groups_by_internal_id.get(group_id_or_name)\n        if group is not None:\n            return group[\"id\"]\n\n        group = self._get_group_by_name(group_id_or_name)\n        if group is not None:\n            return group[\"id\"]\n\n        return None\n\n    def _is_phone_number(self, phone_number: str) -&gt; bool:\n        try:\n            parsed_number = phonenumbers.parse(phone_number, region=None)\n            return phonenumbers.is_valid_number(parsed_number)\n        except phonenumbers.phonenumberutil.NumberParseException:\n            return False\n\n    def _is_valid_uuid(self, receiver_uuid: str) -&gt; bool:\n        try:\n            uuid.UUID(str(receiver_uuid))\n            return True  # noqa: TRY300\n        except ValueError:\n            return False\n\n    def _is_username(self, receiver_username: str) -&gt; bool:  # noqa: PLR0911\n        \"\"\"\n        Check if username has correct format, as described in\n        https://support.signal.org/hc/en-us/articles/6712070553754-Phone-Number-Privacy-and-Usernames#username_req\n        Additionally, cannot have more than 9 digits and the digits cannot be 00.\n        \"\"\"\n        split_username = receiver_username.split(\".\")\n        if len(split_username) == 2:  # noqa: PLR2004\n            characters = split_username[0]\n            digits = split_username[1]\n            if len(characters) &lt; 3 or len(characters) &gt; 32:  # noqa: PLR2004\n                return False\n            if not re.match(r\"^[A-Za-z\\d_]+$\", characters):\n                return False\n            if len(digits) &lt; 2 or len(digits) &gt; 9:  # noqa: PLR2004\n                return False\n            try:\n                digits = int(digits)\n                if digits == 0:  # noqa: SIM103\n                    return False\n                return True  # noqa: TRY300\n            except ValueError:\n                return False\n        else:\n            return False\n\n    def _is_group_id(self, group_id: str) -&gt; bool:\n        \"\"\"Check if group_id has the right format, e.g.\n\n              random string                                              length 66\n              \u2193                                                          \u2193\n        group.OyZzqio1xDmYiLsQ1VsqRcUFOU4tK2TcECmYt2KeozHJwglMBHAPS7jlkrm=\n        \u2191                                                                \u2191\n        prefix                                                           suffix\n        \"\"\"\n        if group_id is None:\n            return False\n\n        return re.match(r\"^group\\.[a-zA-Z0-9]{59}=$\", group_id)\n\n    def _is_internal_id(self, internal_id: str) -&gt; bool:\n        if internal_id is None:\n            return False\n        return internal_id[-1] == \"=\"\n\n    def _get_group_by_name(self, group_name: str) -&gt; dict[str, Any] | None:\n        groups = self._groups_by_name.get(group_name)\n        if groups is not None:\n            if len(groups) &gt; 1:\n                error_msg = f\"[Bot] There is more than one group named '{group_name}',\"\n                error_msg += \" using the first one.\"\n                self._logger.warning(error_msg)\n            return groups[0]\n        return None\n\n    # see https://stackoverflow.com/questions/55184226/catching-exceptions-in-individual-tasks-and-restarting-them\n    async def _rerun_on_exception(self, coro, *args, **kwargs):  # noqa: ANN001, ANN002, ANN003, ANN202\n        \"\"\"Restart coroutine by waiting an exponential time deplay\"\"\"\n        max_sleep = 5 * 60  # sleep for at most 5 mins until rerun\n        reset = 3 * 60  # reset after 3 minutes running successfully\n        init_sleep = 1  # always start with sleeping for 1 second\n\n        next_sleep = init_sleep\n        while True:\n            start_t = int(time.monotonic())  # seconds\n\n            try:\n                return await coro(*args, **kwargs)\n            except asyncio.CancelledError:\n                raise\n            except Exception:  # noqa: BLE001\n                traceback.print_exc()\n\n            end_t = int(time.monotonic())  # seconds\n\n            if end_t - start_t &lt; reset:\n                sleep_t = next_sleep\n                next_sleep = min(max_sleep, next_sleep * 2)  # double sleep time\n            else:\n                next_sleep = init_sleep  # reset sleep time\n                sleep_t = next_sleep\n\n            self._logger.warning(f\"Restarting coroutine in {sleep_t} seconds\")  # noqa: G004\n            await asyncio.sleep(sleep_t)\n\n    async def _produce_consume_messages(\n        self,\n        producers: int = 1,\n        consumers: int = 3,\n    ) -&gt; None:\n        for task in itertools.chain(self._consume_tasks, self._produce_tasks):\n            task.cancel()\n\n        self._produce_tasks.clear()\n\n        for n in range(1, producers + 1):\n            produce_task = self._rerun_on_exception(self._produce, n)\n            produce_task = asyncio.create_task(produce_task)\n            self._store_reference_to_task(produce_task, self._produce_tasks)\n\n        self._consume_tasks.clear()\n\n        for n in range(1, consumers + 1):\n            consume_task = self._rerun_on_exception(self._consume, n)\n            consume_task = asyncio.create_task(consume_task)\n            self._store_reference_to_task(consume_task, self._consume_tasks)\n\n    async def _produce(self, name: int) -&gt; None:\n        self._logger.info(f\"[Bot] Producer #{name} started\")  # noqa: G004\n        try:\n            async for raw_message in self._signal.receive():\n                self._logger.info(f\"[Raw Message] {raw_message}\")  # noqa: G004\n\n                try:\n                    message = await Message.parse(self._signal, raw_message)\n                except UnknownMessageFormatError:\n                    continue\n\n                await self._process_updates(message)\n\n                await self._ask_commands_to_handle(message)\n\n        except ReceiveMessagesError as e:\n            # TODO: retry strategy  # noqa: TD002, TD003\n            raise SignalBotError(f\"Cannot receive messages: {e}\")  # noqa: B904, EM102, TRY003\n\n    def _should_react_for_contact(\n        self,\n        message: Message,\n        contacts: list[str] | bool,  # noqa: FBT001\n        group_ids: list[str] | bool,  # noqa: FBT001\n    ) -&gt; bool:\n        \"\"\"Is the command activated for a certain chat or group?\"\"\"\n        # Case 1: Private message\n        if message.is_private():\n            # a) registered for all numbers\n            if isinstance(contacts, bool) and contacts:\n                return True\n\n            # b) whitelisted numbers\n            if isinstance(contacts, list) and message.source in contacts:\n                return True\n\n        # Case 2: Group message\n        if message.is_group():\n            # a) registered for all groups\n            if isinstance(group_ids, bool) and group_ids:\n                return True\n\n            # b) whitelisted group ids\n            group_id = self._groups_by_internal_id.get(message.group, {}).get(\"id\")\n            if isinstance(group_ids, list) and group_id and group_id in group_ids:\n                return True\n\n        return False\n\n    def _should_react_for_lambda(\n        self,\n        message: Message,\n        f: Callable[[Message], bool] | None = None,\n    ) -&gt; bool:\n        if f is None:\n            return True\n\n        return f(message)\n\n    async def _ask_commands_to_handle(self, message: Message) -&gt; None:\n        for command, contacts, group_ids, f in self.commands:\n            if not self._should_react_for_contact(message, contacts, group_ids):\n                continue\n\n            if not self._should_react_for_lambda(message, f):\n                continue\n\n            await self._q.put((command, message, time.perf_counter()))\n\n    async def _consume(self, name: int) -&gt; None:\n        self._logger.info(f\"[Bot] Consumer #{name} started\")  # noqa: G004\n        while True:\n            try:\n                await self._consume_new_item(name)\n            except Exception:  # noqa: BLE001, PERF203, S112\n                continue\n\n    async def _consume_new_item(self, name: int) -&gt; None:\n        command, message, t = await self._q.get()\n        now = time.perf_counter()\n        self._logger.info(\n            f\"[Bot] Consumer #{name} got new job in {now - t:0.5f} seconds\"  # noqa: G004\n        )\n\n        # handle Command\n        try:\n            context = Context(self, message)\n            await command.handle(context)\n        except Exception:\n            self._logger.exception(f\"[{command.__class__.__name__}]\")  # noqa: G004\n            raise\n\n        # done\n        self._q.task_done()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.__init__","title":"<code>__init__(config)</code>","text":"<p>Initilization for the SignalBot.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary with the bot configuration.</p> required <p>Example config: <pre><code># ======= Mandatory fields ========\nsignal_service: \"127.0.0.1:8080\"\nphone_number: \"+49123456789\"\n\n# ======= Optional fields ========\nstorage:\n    redis_host: \"redis\"\n    redis_port: 6379\nretry_interval: 1\ndownload_attachments: True\n</code></pre></p> Source code in <code>src/signalbot/bot.py</code> <pre><code>def __init__(self, config: dict) -&gt; None:\n    \"\"\"Initilization for the SignalBot.\n\n    Args:\n        config: Dictionary with the bot configuration.\n\n    Example config:\n    ```yaml\n    # ======= Mandatory fields ========\n    signal_service: \"127.0.0.1:8080\"\n    phone_number: \"+49123456789\"\n\n    # ======= Optional fields ========\n    storage:\n        redis_host: \"redis\"\n        redis_port: 6379\n    retry_interval: 1\n    download_attachments: True\n    ```\n    \"\"\"\n    self._logger = logging.getLogger(LOGGER_NAME)\n\n    self.config = config\n\n    self._commands_to_be_registered: CommandList = []  # populated by .register()\n    self.commands: CommandList = []  # populated by .start()\n\n    self.groups = []  # populated by .start()\n    self._groups_by_id = {}\n    self._groups_by_internal_id = {}\n    self._groups_by_name = defaultdict(list)\n\n    try:\n        self._phone_number = self.config[\"phone_number\"]\n        self._signal_service = self.config[\"signal_service\"]\n        download_attachments = self.config.get(\"download_attachments\", True)\n        self._signal = SignalAPI(\n            self._signal_service,\n            self._phone_number,\n            download_attachments,\n        )\n    except KeyError:\n        raise SignalBotError(\"Could not initialize SignalAPI with given config\")  # noqa: B904, EM101, TRY003\n\n    try:\n        self._event_loop = asyncio.get_event_loop()\n    except RuntimeError:\n        self._event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._event_loop)\n\n    self._q = asyncio.Queue()\n    self._running_tasks: set[asyncio.Task] = set()\n\n    self._produce_tasks: set[asyncio.Task] = set()\n    self._consume_tasks: set[asyncio.Task] = set()\n\n    try:\n        self.scheduler = AsyncIOScheduler(event_loop=self._event_loop)\n    except Exception as e:  # noqa: BLE001\n        raise SignalBotError(f\"Could not initialize scheduler: {e}\")  # noqa: B904, EM102, TRY003\n\n    config_storage = {}\n    try:\n        config_storage = self.config[\"storage\"]\n        if config_storage.get(\"type\") == \"sqlite\":\n            self._sqlite_db = config_storage[\"sqlite_db\"]\n            check_same_thread = config_storage.get(\"check_same_thread\", True)\n            self.storage = SQLiteStorage(\n                self._sqlite_db,\n                check_same_thread=check_same_thread,\n            )\n            self._logger.info(\"sqlite storage initilized\")\n        else:\n            self._redis_host = config_storage[\"redis_host\"]\n            self._redis_port = config_storage[\"redis_port\"]\n            self.storage = RedisStorage(self._redis_host, self._redis_port)\n            self._logger.info(\"redis storage initilized\")\n    except Exception:  # noqa: BLE001\n        self.storage = SQLiteStorage()\n        if config_storage.get(\"type\") != \"in-memory\":\n            self._logger.warning(\n                \"[Bot] Could not initialize Redis and no SQLite DB name was given.\"\n                \" In-memory storage will be used.\"\n                \" Restarting will delete the storage!\"\n                \" Add storage: {'type': 'in-memory'}\"\n                \" to the config to silence this error.\",\n            )\n        if \"redis_host\" in config_storage:\n            self._logger.warning(\n                f\"[Bot] Redis initialization error: {traceback.format_exc()}\",  # noqa: G004\n            )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.delete_attachment","title":"<code>delete_attachment(attachment_filename)</code>  <code>async</code>","text":"<p>Delete an attachment from local storage.</p> <p>Parameters:</p> Name Type Description Default <code>attachment_filename</code> <code>str</code> <p>File name to delete.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def delete_attachment(self, attachment_filename: str) -&gt; None:\n    \"\"\"Delete an attachment from local storage.\n\n    Args:\n        attachment_filename: File name to delete.\n    \"\"\"\n    await self._signal.delete_attachment(attachment_filename)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.react","title":"<code>react(message, emoji)</code>  <code>async</code>","text":"<p>React to a message with an emoji.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to react to.</p> required <code>emoji</code> <code>str</code> <p>Emoji reaction value.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def react(self, message: Message, emoji: str) -&gt; None:\n    \"\"\"React to a message with an emoji.\n\n    Args:\n        message: The message to react to.\n        emoji: Emoji reaction value.\n    \"\"\"\n    # TODO: check that emoji is really an emoji  # noqa: TD002, TD003\n    recipient = message.recipient()\n    recipient = self._resolve_receiver(recipient)\n    target_author = message.source\n    timestamp = message.timestamp\n    await self._signal.react(recipient, emoji, target_author, timestamp)\n    self._logger.info(f\"[Bot] New reaction: {emoji}\")  # noqa: G004\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.receipt","title":"<code>receipt(message, receipt_type)</code>  <code>async</code>","text":"<p>Send a read or viewed receipt for a message if supported.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to acknowledge.</p> required <code>receipt_type</code> <code>Literal['read', 'viewed']</code> <p>Receipt type to send.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def receipt(\n    self,\n    message: Message,\n    receipt_type: Literal[\"read\", \"viewed\"],\n) -&gt; None:\n    \"\"\"Send a read or viewed receipt for a message if supported.\n\n    Args:\n        message: The message to acknowledge.\n        receipt_type: Receipt type to send.\n    \"\"\"\n    if message.group is not None:\n        self._logger.warning(\"[Bot] Receipts are not supported for groups\")\n        return\n\n    recipient = self._resolve_receiver(message.recipient())\n    await self._signal.receipt(recipient, receipt_type, message.timestamp)\n    self._logger.info(f\"[Bot] Receipt: {receipt_type}\")  # noqa: G004\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.register","title":"<code>register(command, contacts=True, groups=True, f=None)</code>","text":"<p>Register a command with optional contact/group filters.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>Command instance to register.</p> required <code>contacts</code> <code>list[str] | bool</code> <p>Allowed contacts or True for all.</p> <code>True</code> <code>groups</code> <code>list[str] | bool</code> <p>Allowed groups or True for all.</p> <code>True</code> <code>f</code> <code>Callable[[Message], bool] | None</code> <p>Optional function to further filter messages.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def register(\n    self,\n    command: Command,\n    contacts: list[str] | bool = True,  # noqa: FBT001, FBT002\n    groups: list[str] | bool = True,  # noqa: FBT001, FBT002\n    f: Callable[[Message], bool] | None = None,\n) -&gt; None:\n    \"\"\"Register a command with optional contact/group filters.\n\n    Args:\n        command: Command instance to register.\n        contacts: Allowed contacts or True for all.\n        groups: Allowed groups or True for all.\n        f: Optional function to further filter messages.\n    \"\"\"\n    command.bot = self\n    command.setup()\n    self._commands_to_be_registered.append((command, contacts, groups, f))\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.remote_delete","title":"<code>remote_delete(receiver, timestamp)</code>  <code>async</code>","text":"<p>Delete a previously sent message.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Recipient identifier.</p> required <code>timestamp</code> <code>int</code> <p>Timestamp of the message to delete.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The timestamp of the delete action.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def remote_delete(self, receiver: str, timestamp: int) -&gt; int:\n    \"\"\"Delete a previously sent message.\n\n    Args:\n        receiver: Recipient identifier.\n        timestamp: Timestamp of the message to delete.\n\n    Returns:\n        The timestamp of the delete action.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n\n    resp = await self._signal.remote_delete(\n        receiver,\n        timestamp=timestamp,\n    )\n    resp_payload = await resp.json()\n    ret_timestamp = int(resp_payload[\"timestamp\"])\n    self._logger.info(f\"[Bot] Deleted message with timestamp {timestamp}\")  # noqa: G004\n\n    return ret_timestamp\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.send","title":"<code>send(receiver, text, *, base64_attachments=None, link_preview=None, quote_author=None, quote_mentions=None, quote_message=None, quote_timestamp=None, mentions=None, edit_timestamp=None, text_mode=None, view_once=False)</code>  <code>async</code>","text":"<p>Send or edit a message.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>The recipient of the message.</p> required <code>text</code> <code>str</code> <p>The content of the message.</p> required <code>base64_attachments</code> <code>list | None</code> <p>List of attachments encoded in base64.</p> <code>None</code> <code>link_preview</code> <code>LinkPreview | None</code> <p>Link previews to be sent with the message.</p> <code>None</code> <code>quote_author</code> <code>str | None</code> <p>The author of the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_mentions</code> <code>list | None</code> <p>List of mentioned users in the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_message</code> <code>str | None</code> <p>The content of the quoted message, required if quote_message is set.</p> <code>None</code> <code>quote_timestamp</code> <code>int | None</code> <p>The timestamp of the quoted message, required if quote_message is set.</p> <code>None</code> <code>mentions</code> <code>list[dict[str, Any]] | None</code> <p>List of dictionary of mentions, it has the format <code>[{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]</code>.</p> <code>None</code> <code>edit_timestamp</code> <code>int | None</code> <p>The timestamp of the message to edit, if not set a new message will be sent.</p> <code>None</code> <code>text_mode</code> <code>str | None</code> <p>The text mode of the message, can be \"normal\" or \"styled\".</p> <code>None</code> <code>view_once</code> <code>bool</code> <p>Whether the message should be view once or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>The timestamp of the sent or edited message.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def send(  # noqa: PLR0913\n    self,\n    receiver: str,\n    text: str,\n    *,\n    base64_attachments: list | None = None,\n    link_preview: LinkPreview | None = None,\n    quote_author: str | None = None,\n    quote_mentions: list | None = None,\n    quote_message: str | None = None,\n    quote_timestamp: int | None = None,\n    mentions: (\n        list[dict[str, Any]] | None\n    ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n    edit_timestamp: int | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Send or edit a message.\n\n    Args:\n        receiver: The recipient of the message.\n        text: The content of the message.\n        base64_attachments: List of attachments encoded in base64.\n        link_preview: Link previews to be sent with the message.\n        quote_author: The author of the quoted message, required if quote_message is\n            set.\n        quote_mentions: List of mentioned users in the quoted message, required if\n            quote_message is set.\n        quote_message: The content of the quoted message, required if quote_message\n            is set.\n        quote_timestamp: The timestamp of the quoted message, required if\n            quote_message is set.\n        mentions: List of dictionary of mentions, it has the format\n            `[{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]`.\n        edit_timestamp: The timestamp of the message to edit, if not set a new\n            message will be sent.\n        text_mode: The text mode of the message, can be \"normal\" or \"styled\".\n        view_once: Whether the message should be view once or not.\n\n    Returns:\n        The timestamp of the sent or edited message.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    link_preview_raw = link_preview.model_dump() if link_preview else None\n\n    resp = await self._signal.send(\n        receiver,\n        text,\n        base64_attachments=base64_attachments,\n        link_preview=link_preview_raw,\n        quote_author=quote_author,\n        quote_mentions=quote_mentions,\n        quote_message=quote_message,\n        quote_timestamp=quote_timestamp,\n        mentions=mentions,\n        text_mode=text_mode,\n        edit_timestamp=edit_timestamp,\n        view_once=view_once,\n    )\n    resp_payload = await resp.json()\n    timestamp = int(resp_payload[\"timestamp\"])\n    self._logger.info(f\"[Bot] New message {timestamp} sent:\\n{text}\")  # noqa: G004\n\n    return timestamp\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.signal_cli_rest_api_mode","title":"<code>signal_cli_rest_api_mode()</code>  <code>async</code>","text":"<p>Return the signal-cli-rest-api mode.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def signal_cli_rest_api_mode(self) -&gt; str:\n    \"\"\"Return the signal-cli-rest-api mode.\"\"\"\n    return await self._signal.get_signal_cli_rest_api_mode()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.signal_cli_rest_api_version","title":"<code>signal_cli_rest_api_version()</code>  <code>async</code>","text":"<p>Return the signal-cli-rest-api version.</p> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def signal_cli_rest_api_version(self) -&gt; str:\n    \"\"\"Return the signal-cli-rest-api version.\"\"\"\n    return await self._signal.get_signal_cli_rest_api_version()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.start","title":"<code>start(run_forever=True)</code>","text":"<p>Start the bot event loop and scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>run_forever</code> <code>bool</code> <p>Whether to start the event loop or only add the task to it.</p> <code>True</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def start(self, run_forever: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n    \"\"\"Start the bot event loop and scheduler.\n\n    Args:\n        run_forever: Whether to start the event loop or only add the task to it.\n    \"\"\"\n    task = self._event_loop.create_task(\n        self._rerun_on_exception(self._async_post_init),\n    )\n    self._store_reference_to_task(task, self._running_tasks)\n\n    if run_forever:\n        self.scheduler.start()\n\n        self._event_loop.run_forever()\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.start_typing","title":"<code>start_typing(receiver)</code>  <code>async</code>","text":"<p>Send a typing indicator to a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Message recipient.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def start_typing(self, receiver: str) -&gt; None:\n    \"\"\"Send a typing indicator to a receiver.\n\n    Args:\n        receiver: Message recipient.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.start_typing(receiver)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.stop_typing","title":"<code>stop_typing(receiver)</code>  <code>async</code>","text":"<p>Stop a typing indicator for a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Message recipient.</p> required Source code in <code>src/signalbot/bot.py</code> <pre><code>async def stop_typing(self, receiver: str) -&gt; None:\n    \"\"\"Stop a typing indicator for a receiver.\n\n    Args:\n        receiver: Message recipient.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.stop_typing(receiver)\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.update_contact","title":"<code>update_contact(receiver, expiration_in_seconds=None, name=None)</code>  <code>async</code>","text":"<p>Update a contact's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>Contact identifier.</p> required <code>expiration_in_seconds</code> <code>int | None</code> <p>Expiration timer in seconds.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Contact display name.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def update_contact(\n    self,\n    receiver: str,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Update a contact's metadata.\n\n    Args:\n        receiver: Contact identifier.\n        expiration_in_seconds: Expiration timer in seconds.\n        name: Contact display name.\n    \"\"\"\n    receiver = self._resolve_receiver(receiver)\n    await self._signal.update_contact(\n        receiver,\n        expiration_in_seconds=expiration_in_seconds,\n        name=name,\n    )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.SignalBot.update_group","title":"<code>update_group(group_id, base64_avatar=None, description=None, expiration_in_seconds=None, name=None)</code>  <code>async</code>","text":"<p>Update a group's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Group identifier or name.</p> required <code>base64_avatar</code> <code>str | None</code> <p>Base64-encoded avatar.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Group description.</p> <code>None</code> <code>expiration_in_seconds</code> <code>int | None</code> <p>Expiration timer in seconds.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Group display name.</p> <code>None</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>async def update_group(\n    self,\n    group_id: str,\n    base64_avatar: str | None = None,\n    description: str | None = None,\n    expiration_in_seconds: int | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Update a group's metadata.\n\n    Args:\n        group_id: Group identifier or name.\n        base64_avatar: Base64-encoded avatar.\n        description: Group description.\n        expiration_in_seconds: Expiration timer in seconds.\n        name: Group display name.\n    \"\"\"\n    group_id = self._resolve_receiver(group_id)\n    await self._signal.update_group(\n        group_id,\n        base64_avatar=base64_avatar,\n        description=description,\n        expiration_in_seconds=expiration_in_seconds,\n        name=name,\n    )\n</code></pre>"},{"location":"api_bot/#signalbot.bot.enable_console_logging","title":"<code>enable_console_logging(level=logging.WARNING)</code>","text":"<p>Enable console logging for the signalbot logger.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level for the logger.</p> <code>WARNING</code> Source code in <code>src/signalbot/bot.py</code> <pre><code>def enable_console_logging(level: int = logging.WARNING) -&gt; None:\n    \"\"\"Enable console logging for the signalbot logger.\n\n    Args:\n        level: Logging level for the logger.\n    \"\"\"\n    handler = logging.StreamHandler()\n\n    formatter = logging.Formatter(\n        \"%(asctime)s %(name)s [%(levelname)s] - %(funcName)s - %(message)s\"\n    )\n    handler.setFormatter(formatter)\n\n    logger = logging.getLogger(LOGGER_NAME)\n    logger.addHandler(handler)\n    logger.setLevel(level)\n</code></pre>"},{"location":"api_command/","title":"Command","text":""},{"location":"api_command/#signalbot.command.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for commands.</p> <p>To create a command, subclass this class and implement the <code>handle</code> method. Then, register the command with the bot using <code>bot.register(CommandSubclass)</code>.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>class Command(ABC):\n    \"\"\"Abstract base class for commands.\n\n    To create a command, subclass this class and implement the `handle` method.\n    Then, register the command with the bot using `bot.register(CommandSubclass)`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        # The bot attribute is assigned after calling bot.register(Command())\n        self.bot: SignalBot | None = None\n\n    def setup(self) -&gt; None:\n        \"\"\"Optional setup method that can be overridden by subclasses.\n        This method is called after the command is registered with the bot but\n        before any data is retrieved, so it cannot access the group ids.\n        \"\"\"\n        return\n\n    @abstractmethod\n    async def handle(self, context: Context) -&gt; None:\n        \"\"\"Abstract method to handle a command.\n        This method must be implemented by subclasses to define the behavior of the\n            command.\n        Args:\n            context: Chat context containing the received message and other information.\n        \"\"\"\n</code></pre>"},{"location":"api_command/#signalbot.command.Command.handle","title":"<code>handle(context)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to handle a command. This method must be implemented by subclasses to define the behavior of the     command. Args:     context: Chat context containing the received message and other information.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>@abstractmethod\nasync def handle(self, context: Context) -&gt; None:\n    \"\"\"Abstract method to handle a command.\n    This method must be implemented by subclasses to define the behavior of the\n        command.\n    Args:\n        context: Chat context containing the received message and other information.\n    \"\"\"\n</code></pre>"},{"location":"api_command/#signalbot.command.Command.setup","title":"<code>setup()</code>","text":"<p>Optional setup method that can be overridden by subclasses. This method is called after the command is registered with the bot but before any data is retrieved, so it cannot access the group ids.</p> Source code in <code>src/signalbot/command.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Optional setup method that can be overridden by subclasses.\n    This method is called after the command is registered with the bot but\n    before any data is retrieved, so it cannot access the group ids.\n    \"\"\"\n    return\n</code></pre>"},{"location":"api_command/#signalbot.command.regex_triggered","title":"<code>regex_triggered(*by)</code>","text":"<p>Decorator to trigger a command if the message text matches any of the provided regex patterns.</p> <p>Parameters:</p> Name Type Description Default <code>*by</code> <code>str | Pattern[str]</code> <p>A variable number of strings or compiled regex patterns to match the message text against.</p> <code>()</code> Source code in <code>src/signalbot/command.py</code> <pre><code>def regex_triggered(\n    *by: str | re.Pattern[str],\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"Decorator to trigger a command if the message text matches any of the provided\n    regex patterns.\n\n    Args:\n        *by: A variable number of strings or compiled regex patterns to match the\n            message text against.\n    \"\"\"\n\n    def decorator_regex_triggered(func: Callable[P, T]) -&gt; Callable[P, T]:\n        @functools.wraps(func)\n        async def wrapper_regex_triggered(\n            *args: P.args, **kwargs: P.kwargs\n        ) -&gt; T | None:\n            c: Context = args[1]\n            text = c.message.text\n            if not isinstance(text, str):\n                return None\n            matches = [bool(re.search(pattern, text)) for pattern in by]\n            if True not in matches:\n                return None\n            return await func(*args, **kwargs)\n\n        return wrapper_regex_triggered\n\n    return decorator_regex_triggered\n</code></pre>"},{"location":"api_command/#signalbot.command.triggered","title":"<code>triggered(*by, case_sensitive=False)</code>","text":"<p>Decorator to trigger a command if the message text matches any of the provided strings.</p> <p>Parameters:</p> Name Type Description Default <code>*by</code> <code>str</code> <p>A variable number of strings to match the message text against.</p> <code>()</code> <code>case_sensitive</code> <code>bool</code> <p>Whether the matching should be case sensitive.</p> <code>False</code> Source code in <code>src/signalbot/command.py</code> <pre><code>def triggered(\n    *by: str, case_sensitive: bool = False\n) -&gt; Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"Decorator to trigger a command if the message text matches any of the provided\n    strings.\n\n    Args:\n        *by: A variable number of strings to match the message text against.\n        case_sensitive: Whether the matching should be case sensitive.\n    \"\"\"\n\n    def decorator_triggered(func: Callable[P, T]) -&gt; Callable[P, T]:\n        @functools.wraps(func)\n        async def wrapper_triggered(*args: P.args, **kwargs: P.kwargs) -&gt; T | None:\n            c: Context = args[1]\n            text = c.message.text\n            if not isinstance(text, str):\n                return None\n\n            by_words = by\n            if not case_sensitive:\n                text = text.lower()\n                by_words = [t.lower() for t in by_words]\n            if text not in by_words:\n                return None\n\n            return await func(*args, **kwargs)\n\n        return wrapper_triggered\n\n    return decorator_triggered\n</code></pre>"},{"location":"api_context/","title":"Context","text":""},{"location":"api_context/#signalbot.context.Context","title":"<code>Context</code>","text":"<p>Context is a helper class that provides methods to reply, edit, react, etc. to a message. This is useful to avoid having to pass the recipient and other arguments to the bot's methods manually.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>class Context:\n    \"\"\"\n    Context is a helper class that provides methods to reply, edit, react, etc. to a\n    message. This is useful to avoid having to pass the recipient and other arguments to\n    the bot's methods manually.\n    \"\"\"\n\n    def __init__(self, bot: SignalBot, message: Message) -&gt; None:\n        self.bot = bot\n        self.message = message\n\n    async def send(  # noqa: PLR0913\n        self,\n        text: str,\n        *,\n        base64_attachments: list[str] | None = None,\n        link_preview: LinkPreview | None = None,\n        mentions: list[dict[str, Any]] | None = None,\n        text_mode: str | None = None,\n        view_once: bool = False,\n    ) -&gt; int:\n        \"\"\"Same as\n         [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n        but with the recipient set to the message's recipient.\"\"\"\n        return await self.bot.send(\n            self.message.recipient(),\n            text,\n            base64_attachments=base64_attachments,\n            mentions=mentions,\n            text_mode=text_mode,\n            link_preview=link_preview,\n            view_once=view_once,\n        )\n\n    async def edit(  # noqa: PLR0913\n        self,\n        text: str,\n        edit_timestamp: int,\n        *,\n        base64_attachments: list[str] | None = None,\n        link_preview: LinkPreview | None = None,\n        mentions: list[dict[str, Any]] | None = None,\n        text_mode: str | None = None,\n        view_once: bool = False,\n    ) -&gt; int:\n        \"\"\"Same as\n         [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n        but with the recipient and timestamp set to the message's.\"\"\"\n        return await self.bot.send(\n            self.message.recipient(),\n            text,\n            base64_attachments=base64_attachments,\n            mentions=mentions,\n            text_mode=text_mode,\n            edit_timestamp=edit_timestamp,\n            link_preview=link_preview,\n            view_once=view_once,\n        )\n\n    async def reply(  # noqa: PLR0913\n        self,\n        text: str,\n        *,\n        base64_attachments: list[str] | None = None,\n        link_preview: LinkPreview | None = None,\n        mentions: (\n            list[dict[str, Any]] | None\n        ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n        text_mode: str | None = None,\n        view_once: bool = False,\n    ) -&gt; int:\n        \"\"\"Same as\n         [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n        but with the quote arguments set to the message's.\"\"\"\n        send_mentions = self._convert_receive_mentions_into_send_mentions(\n            self.message.mentions,\n        )\n        return await self.bot.send(\n            self.message.recipient(),\n            text,\n            base64_attachments=base64_attachments,\n            quote_author=self.message.source,\n            quote_mentions=send_mentions,\n            quote_message=self.message.text,\n            quote_timestamp=self.message.timestamp,\n            mentions=mentions,\n            text_mode=text_mode,\n            link_preview=link_preview,\n            view_once=view_once,\n        )\n\n    async def react(self, emoji: str) -&gt; None:\n        \"\"\"Same as\n         [signalbot.SignalBot.react()](api_bot.md#signalbot.SignalBot.react)\n        but with the recipient set to the message's recipient.\"\"\"\n        await self.bot.react(self.message, emoji)\n\n    async def receipt(self, receipt_type: Literal[\"read\", \"viewed\"]) -&gt; None:\n        \"\"\"Same as\n         [signalbot.SignalBot.receipt()](api_bot.md#signalbot.SignalBot.receipt)\n        but with the recipient set to the message's recipient.\"\"\"\n        await self.bot.receipt(self.message, receipt_type)\n\n    async def start_typing(self) -&gt; None:\n        \"\"\"Same as\n        [signalbot.SignalBot.start_typing()](api_bot.md#signalbot.SignalBot.start_typing)\n         but with the recipient set to the message's recipient.\"\"\"\n        await self.bot.start_typing(self.message.recipient())\n\n    async def stop_typing(self) -&gt; None:\n        \"\"\"Same as\n        [signalbot.SignalBot.stop_typing()](api_bot.md#signalbot.SignalBot.stop_typing)\n         but with the recipient set to the message's recipient.\"\"\"\n        await self.bot.stop_typing(self.message.recipient())\n\n    async def remote_delete(self, timestamp: int) -&gt; int:\n        \"\"\"Same as\n        [signalbot.SignalBot.remote_delete()](api_bot.md#signalbot.SignalBot.remote_delete)\n        but with the recipient and timestamp set to the message's.\"\"\"\n        return await self.bot.remote_delete(\n            self.message.recipient(), timestamp=timestamp\n        )\n\n    def _convert_receive_mentions_into_send_mentions(\n        self,\n        mentions: list[dict[str, Any]] | None = None,\n    ) -&gt; list[dict[str, Any]] | None:\n        if mentions is None:\n            return None\n\n        send_mentions = deepcopy(mentions)\n        for mention in send_mentions:\n            if \"author\" not in mention:\n                mention[\"author\"] = mention[\"uuid\"]\n        return send_mentions\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.edit","title":"<code>edit(text, edit_timestamp, *, base64_attachments=None, link_preview=None, mentions=None, text_mode=None, view_once=False)</code>  <code>async</code>","text":"<p>Same as  signalbot.SignalBot.send() but with the recipient and timestamp set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def edit(  # noqa: PLR0913\n    self,\n    text: str,\n    edit_timestamp: int,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the recipient and timestamp set to the message's.\"\"\"\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        mentions=mentions,\n        text_mode=text_mode,\n        edit_timestamp=edit_timestamp,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.react","title":"<code>react(emoji)</code>  <code>async</code>","text":"<p>Same as  signalbot.SignalBot.react() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def react(self, emoji: str) -&gt; None:\n    \"\"\"Same as\n     [signalbot.SignalBot.react()](api_bot.md#signalbot.SignalBot.react)\n    but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.react(self.message, emoji)\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.receipt","title":"<code>receipt(receipt_type)</code>  <code>async</code>","text":"<p>Same as  signalbot.SignalBot.receipt() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def receipt(self, receipt_type: Literal[\"read\", \"viewed\"]) -&gt; None:\n    \"\"\"Same as\n     [signalbot.SignalBot.receipt()](api_bot.md#signalbot.SignalBot.receipt)\n    but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.receipt(self.message, receipt_type)\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.remote_delete","title":"<code>remote_delete(timestamp)</code>  <code>async</code>","text":"<p>Same as signalbot.SignalBot.remote_delete() but with the recipient and timestamp set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def remote_delete(self, timestamp: int) -&gt; int:\n    \"\"\"Same as\n    [signalbot.SignalBot.remote_delete()](api_bot.md#signalbot.SignalBot.remote_delete)\n    but with the recipient and timestamp set to the message's.\"\"\"\n    return await self.bot.remote_delete(\n        self.message.recipient(), timestamp=timestamp\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.reply","title":"<code>reply(text, *, base64_attachments=None, link_preview=None, mentions=None, text_mode=None, view_once=False)</code>  <code>async</code>","text":"<p>Same as  signalbot.SignalBot.send() but with the quote arguments set to the message's.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def reply(  # noqa: PLR0913\n    self,\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: (\n        list[dict[str, Any]] | None\n    ) = None,  # [{ \"author\": \"uuid\" , \"start\": 0, \"length\": 1 }]\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the quote arguments set to the message's.\"\"\"\n    send_mentions = self._convert_receive_mentions_into_send_mentions(\n        self.message.mentions,\n    )\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        quote_author=self.message.source,\n        quote_mentions=send_mentions,\n        quote_message=self.message.text,\n        quote_timestamp=self.message.timestamp,\n        mentions=mentions,\n        text_mode=text_mode,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.send","title":"<code>send(text, *, base64_attachments=None, link_preview=None, mentions=None, text_mode=None, view_once=False)</code>  <code>async</code>","text":"<p>Same as  signalbot.SignalBot.send() but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def send(  # noqa: PLR0913\n    self,\n    text: str,\n    *,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    mentions: list[dict[str, Any]] | None = None,\n    text_mode: str | None = None,\n    view_once: bool = False,\n) -&gt; int:\n    \"\"\"Same as\n     [signalbot.SignalBot.send()](api_bot.md#signalbot.SignalBot.send)\n    but with the recipient set to the message's recipient.\"\"\"\n    return await self.bot.send(\n        self.message.recipient(),\n        text,\n        base64_attachments=base64_attachments,\n        mentions=mentions,\n        text_mode=text_mode,\n        link_preview=link_preview,\n        view_once=view_once,\n    )\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.start_typing","title":"<code>start_typing()</code>  <code>async</code>","text":"<p>Same as signalbot.SignalBot.start_typing()  but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def start_typing(self) -&gt; None:\n    \"\"\"Same as\n    [signalbot.SignalBot.start_typing()](api_bot.md#signalbot.SignalBot.start_typing)\n     but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.start_typing(self.message.recipient())\n</code></pre>"},{"location":"api_context/#signalbot.context.Context.stop_typing","title":"<code>stop_typing()</code>  <code>async</code>","text":"<p>Same as signalbot.SignalBot.stop_typing()  but with the recipient set to the message's recipient.</p> Source code in <code>src/signalbot/context.py</code> <pre><code>async def stop_typing(self) -&gt; None:\n    \"\"\"Same as\n    [signalbot.SignalBot.stop_typing()](api_bot.md#signalbot.SignalBot.stop_typing)\n     but with the recipient set to the message's recipient.\"\"\"\n    await self.bot.stop_typing(self.message.recipient())\n</code></pre>"},{"location":"api_linkpreview/","title":"LinkPreview","text":""},{"location":"api_linkpreview/#signalbot.link_previews.LinkPreview","title":"<code>LinkPreview</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass to representing a link preview.</p> <p>Attributes:</p> Name Type Description <code>base64_thumbnail</code> <code>str | None</code> <p>The base64 encoded thumbnail of the link preview, if available.</p> <code>title</code> <code>str</code> <p>The title of the link preview.</p> <code>description</code> <code>str | None</code> <p>The description of the link preview, if available.</p> <code>url</code> <code>str</code> <p>The url of the link preview.</p> <code>id</code> <code>str | None</code> <p>The local filename for a received link preview.</p> Source code in <code>src/signalbot/link_previews.py</code> <pre><code>class LinkPreview(BaseModel):\n    \"\"\"Dataclass to representing a link preview.\n\n    Attributes:\n        base64_thumbnail: The base64 encoded thumbnail of the link preview, if\n            available.\n        title: The title of the link preview.\n        description: The description of the link preview, if available.\n        url: The url of the link preview.\n        id: The local filename for a received link preview.\n    \"\"\"\n\n    base64_thumbnail: str | None\n    title: str\n    description: str | None\n    url: str\n    id: str | None = None\n</code></pre>"},{"location":"api_message/","title":"Message","text":""},{"location":"api_message/#signalbot.message.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"<p>Class representing a Signal message.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>The phone number or UUID of the sender of the message.</p> <code>source_number</code> <code>str | None</code> <p>The phone number of the sender of the message. This is <code>None</code> for signal contacts where the phone number was not exchanged.</p> <code>source_uuid</code> <code>str</code> <p>The UUID of the sender of the message.</p> <code>timestamp</code> <code>int</code> <p>The timestamp of when the message was sent.</p> <code>type</code> <code>MessageType</code> <p>The type of the message.</p> <code>text</code> <code>str</code> <p>The text content of the message.</p> <code>base64_attachments</code> <code>list[str]</code> <p>A list of attachments in the message, encoded as base64 strings.</p> <code>attachments_local_filenames</code> <code>list[str]</code> <p>A list of local filenames for the attachments in the message.</p> <code>view_once</code> <code>bool</code> <p>A boolean indicating whether the message is a view-once message.</p> <code>link_previews</code> <code>list[LinkPreview]</code> <p>A list of <code>LinkPreview</code> objects representing the link previews in the message.</p> <code>group</code> <code>str | None</code> <p>The UUID of the group chat the message was sent in, or <code>None</code> if the message was sent in a user chat.</p> <code>reaction</code> <code>str | None</code> <p>The reaction emoji if the message is a reaction.</p> <code>mentions</code> <code>list[str]</code> <p>A list of UUIDs of users mentioned in the message.</p> <code>quote</code> <code>Quote | None</code> <p>An object representing the quoted message if the message is a quote.</p> <code>read_messages</code> <code>list[dict] | None</code> <p>A list of dictionaries representing the messages that have been read if the message is a <code>MessageType.READ_MESSAGE</code></p> <code>target_sent_timestamp</code> <code>int | None</code> <p>The timestamp of the original message that was edited, if the message is a <code>MessageType.EDIT_MESSAGE</code>.</p> <code>remote_delete_timestamp</code> <code>int | None</code> <p>The timestamp of the original message that was deleted, the message is a <code>MessageType.DELETE_MESSAGE</code>.</p> <code>updated_group_id</code> <code>str | None</code> <p>The UUID of the group that was updated, if the message is a <code>MessageType.GROUP_UPDATE_MESSAGE</code>.</p> <code>raw_message</code> <code>str | None</code> <p>The raw JSON string of the message as received from the Signal API.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>@dataclass\nclass Message:\n    \"\"\"Class representing a Signal message.\n\n    Attributes:\n        source: The phone number or UUID of the sender of the message.\n        source_number: The phone number of the sender of the message.\n            This is `None` for signal contacts where the phone number was not exchanged.\n        source_uuid: The UUID of the sender of the message.\n        timestamp: The timestamp of when the message was sent.\n        type: The type of the message.\n        text: The text content of the message.\n        base64_attachments: A list of attachments in the message, encoded as base64\n            strings.\n        attachments_local_filenames: A list of local filenames for the attachments in\n            the message.\n        view_once: A boolean indicating whether the message is a view-once message.\n        link_previews: A list of `LinkPreview` objects representing the link previews in\n            the message.\n        group: The UUID of the group chat the message was sent in, or `None` if the\n            message was sent in a user chat.\n        reaction: The reaction emoji if the message is a reaction.\n        mentions: A list of UUIDs of users mentioned in the message.\n        quote: An object representing the quoted message if the message is a\n            quote.\n        read_messages: A list of dictionaries representing the messages that have been\n            read if the message is a `MessageType.READ_MESSAGE`\n        target_sent_timestamp: The timestamp of the original message that was edited, if\n            the message is a `MessageType.EDIT_MESSAGE`.\n        remote_delete_timestamp: The timestamp of the original message that was deleted,\n            the message is a `MessageType.DELETE_MESSAGE`.\n        updated_group_id: The UUID of the group that was updated, if the message is a\n            `MessageType.GROUP_UPDATE_MESSAGE`.\n        raw_message: The raw JSON string of the message as received from the Signal API.\n    \"\"\"\n\n    source: str\n    source_number: str | None\n    source_uuid: str\n    timestamp: int\n    type: MessageType\n    text: str\n    base64_attachments: list[str] = field(default_factory=list)\n    attachments_local_filenames: list[str] = field(default_factory=list)\n    view_once: bool = False\n    link_previews: list[LinkPreview] = field(default_factory=list)\n    group: str | None = None\n    reaction: str | None = None\n    mentions: list[str] = field(default_factory=list)\n    quote: Quote | None = None\n    read_messages: list[dict] | None = None\n    target_sent_timestamp: int | None = None\n    remote_delete_timestamp: int | None = None\n    updated_group_id: str | None = None\n    raw_message: str | None = None\n\n    def recipient(self) -&gt; str:\n        \"\"\"Get the recipient of the message, which is either the group ID for group\n            chats or the source ID for user chats.\n\n        Returns:\n            The recipient ID of the message.\n        \"\"\"\n        # Case 1: Group chat\n        if self.group:\n            return self.group  # internal ID\n\n        # Case 2: User chat\n        return self.source\n\n    def is_private(self) -&gt; bool:\n        \"\"\"Check if the message is a private (one-on-one) message.\n\n\n        Returns:\n            True if the message is a private (one-on-one) message, False otherwise.\n        \"\"\"\n        return not bool(self.group)\n\n    def is_group(self) -&gt; bool:\n        \"\"\"Check if the message is a group message.\n\n        Returns:\n            True if the message is a group message, False otherwise.\n        \"\"\"\n        return bool(self.group)\n\n    @classmethod\n    def _extract_message_data(  # noqa: C901, PLR0912\n        cls, envelope: dict\n    ) -&gt; tuple[MessageType, dict, int | None, int | None, str | None]:\n        \"\"\"Extract message type, data_message, and timestamps from envelope.\"\"\"\n        target_sent_timestamp = None\n\n        if \"syncMessage\" in envelope:\n            sync_message = envelope[\"syncMessage\"]\n            if sync_message == {}:\n                raise UnknownMessageFormatError\n\n            if \"readMessages\" in sync_message:\n                message_type = MessageType.READ_MESSAGE\n                data_message = {\n                    \"message\": \"\",\n                    \"readMessages\": sync_message[\"readMessages\"],\n                }\n            elif \"type\" in sync_message:\n                if sync_message[\"type\"] == \"CONTACTS_SYNC\":\n                    message_type = MessageType.CONTACT_SYNC_MESSAGE\n                    data_message = {\"message\": \"\"}\n                    target_sent_timestamp = envelope.get(\"timestamp\")\n                else:\n                    raise UnknownMessageFormatError\n            else:\n                message_type = MessageType.SYNC_MESSAGE\n                data_message = sync_message[\"sentMessage\"]\n\n            if \"editMessage\" in data_message:\n                message_type = MessageType.EDIT_MESSAGE\n                target_sent_timestamp = data_message[\"editMessage\"][\n                    \"targetSentTimestamp\"\n                ]\n                data_message = data_message[\"editMessage\"][\"dataMessage\"]\n\n        elif \"dataMessage\" in envelope:\n            message_type = MessageType.DATA_MESSAGE\n            data_message = envelope[\"dataMessage\"]\n\n        elif \"editMessage\" in envelope:\n            message_type = MessageType.EDIT_MESSAGE\n            data_message = envelope[\"editMessage\"][\"dataMessage\"]\n            target_sent_timestamp = envelope[\"editMessage\"][\"targetSentTimestamp\"]\n\n        else:\n            raise UnknownMessageFormatError\n\n        remote_delete_timestamp = None\n        if \"remoteDelete\" in data_message:\n            message_type = MessageType.DELETE_MESSAGE\n            remote_delete_timestamp = data_message[\"remoteDelete\"][\"timestamp\"]\n\n        updated_group_id = None\n        if (\n            \"groupInfo\" in data_message\n            and data_message[\"groupInfo\"][\"type\"] == \"UPDATE\"\n        ):\n            message_type = MessageType.GROUP_UPDATE_MESSAGE\n            updated_group_id = data_message[\"groupInfo\"][\"groupId\"]\n\n        return (\n            message_type,\n            data_message,\n            target_sent_timestamp,\n            remote_delete_timestamp,\n            updated_group_id,\n        )\n\n    @classmethod\n    async def parse(cls, signal: SignalAPI, raw_message_str: str) -&gt; Message:\n        \"\"\"Parse a raw JSON message string from the Signal API into a Message object.\n\n        Args:\n            signal: An instance of the `SignalAPI` class, used to fetch attachments and\n                link previews if necessary.\n            raw_message_str: The raw JSON string of the message as received from the\n                Signal API.\n\n        Returns:\n            A `Message` object representing the parsed message.\n\n        Raises:\n            UnknownMessageFormatError: If the message format is unrecognized or if\n                required fields are missing.\n        \"\"\"\n        try:\n            raw_message = json.loads(raw_message_str)\n        except Exception as exc:\n            raise UnknownMessageFormatError from exc\n\n        envelope = raw_message[\"envelope\"]\n        # General attributes\n        try:\n            source = envelope[\"source\"]\n            source_uuid = envelope[\"sourceUuid\"]\n            timestamp = envelope[\"timestamp\"]\n        except Exception as exc:\n            raise UnknownMessageFormatError from exc\n\n        source_number = envelope.get(\"sourceNumber\")\n\n        (\n            message_type,\n            data_message,\n            target_sent_timestamp,\n            remote_delete_timestamp,\n            updated_group_id,\n        ) = cls._extract_message_data(envelope)\n\n        text = cls._parse_data_message(data_message)\n        group = cls._parse_group_information(data_message)\n        reaction = cls._parse_reaction(data_message)\n        mentions = cls._parse_mentions(data_message)\n        quote = cls._parse_quote(data_message)\n        read_messages = data_message.get(\"readMessages\")\n\n        base64_attachments, attachments_local_filenames, link_previews = [], [], []\n        view_once = False\n        if signal.download_attachments:\n            base64_attachments = await cls._parse_attachments(signal, data_message)\n            attachments_local_filenames = cls._parse_attachments_local_filenames(\n                data_message,\n            )\n            link_previews = await cls._parse_previews(signal, data_message)\n            view_once = data_message.get(\"viewOnce\", False)\n\n        return cls(\n            source,\n            source_number,\n            source_uuid,\n            timestamp,\n            message_type,\n            text,\n            base64_attachments=base64_attachments,\n            attachments_local_filenames=attachments_local_filenames,\n            view_once=view_once,\n            link_previews=link_previews,\n            group=group,\n            reaction=reaction,\n            mentions=mentions,\n            quote=quote,\n            read_messages=read_messages,\n            target_sent_timestamp=target_sent_timestamp,\n            remote_delete_timestamp=remote_delete_timestamp,\n            updated_group_id=updated_group_id,\n            raw_message=raw_message_str,\n        )\n\n    @classmethod\n    async def _parse_attachments(\n        cls, signal: SignalAPI, data_message: dict\n    ) -&gt; list[str]:\n        if \"attachments\" not in data_message:\n            return []\n\n        return [\n            await signal.get_attachment(attachment[\"id\"])\n            for attachment in data_message[\"attachments\"]\n        ]\n\n    @classmethod\n    def _parse_attachments_local_filenames(cls, data_message: dict) -&gt; list[str]:\n        if \"attachments\" not in data_message:\n            return []\n\n        # The [\"id\"] is the local filename and the [\"filename\"] is the remote filename\n        return [attachment[\"id\"] for attachment in data_message[\"attachments\"]]\n\n    @classmethod\n    def _parse_data_message(cls, data_message: dict) -&gt; str:\n        try:\n            return data_message[\"message\"]\n        except KeyError as exc:\n            raise UnknownMessageFormatError from exc\n\n    @classmethod\n    def _parse_group_information(cls, message: dict) -&gt; str:\n        try:\n            return message[\"groupInfo\"][\"groupId\"]\n        except KeyError:\n            return None\n\n    @classmethod\n    def _parse_mentions(cls, data_message: dict) -&gt; list:\n        try:\n            return data_message[\"mentions\"]\n        except KeyError:\n            return []\n\n    @classmethod\n    def _parse_reaction(cls, message: dict) -&gt; str:\n        try:\n            return message[\"reaction\"][\"emoji\"]\n        except KeyError:\n            return None\n\n    @classmethod\n    def _parse_quote(cls, message: dict) -&gt; Quote | None:\n        try:\n            return Quote.model_validate(message[\"quote\"])\n        except KeyError:\n            return None\n\n    def __str__(self) -&gt; str:\n        if self.text is None:\n            return \"\"\n        return self.text\n\n    @classmethod\n    async def _parse_previews(cls, signal: SignalAPI, data_message: dict) -&gt; list:\n        parsed_previews = []\n        try:\n            for preview in data_message[\"previews\"]:\n                img = preview[\"image\"]\n                img_id = None\n                if isinstance(img, dict):\n                    img_id = img[\"id\"]\n\n                base64_thumbnail = None\n                if img_id:\n                    base64_thumbnail = await signal.get_attachment(img_id)\n\n                parsed_previews.append(\n                    LinkPreview(\n                        base64_thumbnail=base64_thumbnail,\n                        title=preview[\"title\"],\n                        description=preview[\"description\"],\n                        url=preview[\"url\"],\n                        id=img_id,\n                    ),\n                )\n        except KeyError:\n            return []\n\n        return parsed_previews\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.is_group","title":"<code>is_group()</code>","text":"<p>Check if the message is a group message.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the message is a group message, False otherwise.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def is_group(self) -&gt; bool:\n    \"\"\"Check if the message is a group message.\n\n    Returns:\n        True if the message is a group message, False otherwise.\n    \"\"\"\n    return bool(self.group)\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.is_private","title":"<code>is_private()</code>","text":"<p>Check if the message is a private (one-on-one) message.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the message is a private (one-on-one) message, False otherwise.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def is_private(self) -&gt; bool:\n    \"\"\"Check if the message is a private (one-on-one) message.\n\n\n    Returns:\n        True if the message is a private (one-on-one) message, False otherwise.\n    \"\"\"\n    return not bool(self.group)\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.parse","title":"<code>parse(signal, raw_message_str)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Parse a raw JSON message string from the Signal API into a Message object.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>SignalAPI</code> <p>An instance of the <code>SignalAPI</code> class, used to fetch attachments and link previews if necessary.</p> required <code>raw_message_str</code> <code>str</code> <p>The raw JSON string of the message as received from the Signal API.</p> required <p>Returns:</p> Type Description <code>Message</code> <p>A <code>Message</code> object representing the parsed message.</p> <p>Raises:</p> Type Description <code>UnknownMessageFormatError</code> <p>If the message format is unrecognized or if required fields are missing.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>@classmethod\nasync def parse(cls, signal: SignalAPI, raw_message_str: str) -&gt; Message:\n    \"\"\"Parse a raw JSON message string from the Signal API into a Message object.\n\n    Args:\n        signal: An instance of the `SignalAPI` class, used to fetch attachments and\n            link previews if necessary.\n        raw_message_str: The raw JSON string of the message as received from the\n            Signal API.\n\n    Returns:\n        A `Message` object representing the parsed message.\n\n    Raises:\n        UnknownMessageFormatError: If the message format is unrecognized or if\n            required fields are missing.\n    \"\"\"\n    try:\n        raw_message = json.loads(raw_message_str)\n    except Exception as exc:\n        raise UnknownMessageFormatError from exc\n\n    envelope = raw_message[\"envelope\"]\n    # General attributes\n    try:\n        source = envelope[\"source\"]\n        source_uuid = envelope[\"sourceUuid\"]\n        timestamp = envelope[\"timestamp\"]\n    except Exception as exc:\n        raise UnknownMessageFormatError from exc\n\n    source_number = envelope.get(\"sourceNumber\")\n\n    (\n        message_type,\n        data_message,\n        target_sent_timestamp,\n        remote_delete_timestamp,\n        updated_group_id,\n    ) = cls._extract_message_data(envelope)\n\n    text = cls._parse_data_message(data_message)\n    group = cls._parse_group_information(data_message)\n    reaction = cls._parse_reaction(data_message)\n    mentions = cls._parse_mentions(data_message)\n    quote = cls._parse_quote(data_message)\n    read_messages = data_message.get(\"readMessages\")\n\n    base64_attachments, attachments_local_filenames, link_previews = [], [], []\n    view_once = False\n    if signal.download_attachments:\n        base64_attachments = await cls._parse_attachments(signal, data_message)\n        attachments_local_filenames = cls._parse_attachments_local_filenames(\n            data_message,\n        )\n        link_previews = await cls._parse_previews(signal, data_message)\n        view_once = data_message.get(\"viewOnce\", False)\n\n    return cls(\n        source,\n        source_number,\n        source_uuid,\n        timestamp,\n        message_type,\n        text,\n        base64_attachments=base64_attachments,\n        attachments_local_filenames=attachments_local_filenames,\n        view_once=view_once,\n        link_previews=link_previews,\n        group=group,\n        reaction=reaction,\n        mentions=mentions,\n        quote=quote,\n        read_messages=read_messages,\n        target_sent_timestamp=target_sent_timestamp,\n        remote_delete_timestamp=remote_delete_timestamp,\n        updated_group_id=updated_group_id,\n        raw_message=raw_message_str,\n    )\n</code></pre>"},{"location":"api_message/#signalbot.message.Message.recipient","title":"<code>recipient()</code>","text":"<p>Get the recipient of the message, which is either the group ID for group     chats or the source ID for user chats.</p> <p>Returns:</p> Type Description <code>str</code> <p>The recipient ID of the message.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>def recipient(self) -&gt; str:\n    \"\"\"Get the recipient of the message, which is either the group ID for group\n        chats or the source ID for user chats.\n\n    Returns:\n        The recipient ID of the message.\n    \"\"\"\n    # Case 1: Group chat\n    if self.group:\n        return self.group  # internal ID\n\n    # Case 2: User chat\n    return self.source\n</code></pre>"},{"location":"api_message/#signalbot.message.MessageType","title":"<code>MessageType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of a Signal message.</p> <p>Attributes:</p> Name Type Description <code>SYNC_MESSAGE</code> <p>Message received in a linked device</p> <code>DATA_MESSAGE</code> <p>Message received in a primary device</p> <code>EDIT_MESSAGE</code> <p>Message received is an edit of a previous message</p> <code>DELETE_MESSAGE</code> <p>Message received is a remote delete of a previous message</p> <code>READ_MESSAGE</code> <p>User read some messages</p> <code>GROUP_UPDATE_MESSAGE</code> <p>An update has been made to a group</p> <code>CONTACT_SYNC_MESSAGE</code> <p>Message received is a contact sync</p> Source code in <code>src/signalbot/message.py</code> <pre><code>class MessageType(Enum):\n    \"\"\"Enum representing the type of a Signal message.\n\n    Attributes:\n        SYNC_MESSAGE: Message received in a linked device\n        DATA_MESSAGE: Message received in a primary device\n        EDIT_MESSAGE: Message received is an edit of a previous message\n        DELETE_MESSAGE: Message received is a remote delete of a previous message\n        READ_MESSAGE: User read some messages\n        GROUP_UPDATE_MESSAGE: An update has been made to a group\n        CONTACT_SYNC_MESSAGE: Message received is a contact sync\n    \"\"\"\n\n    SYNC_MESSAGE = auto()  # Message received in a linked device\n    DATA_MESSAGE = auto()  # Message received in a primary device\n    EDIT_MESSAGE = auto()  # Message received is an edit of a previous message\n    DELETE_MESSAGE = auto()  # Message received is a remote delete of a previous message\n    READ_MESSAGE = auto()  # User read some messages\n    GROUP_UPDATE_MESSAGE = auto()  # An update has been made to a group\n    CONTACT_SYNC_MESSAGE = auto()  # Message received is a contact sync\n</code></pre>"},{"location":"api_message/#signalbot.message.UnknownMessageFormatError","title":"<code>UnknownMessageFormatError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a message with an unknown format is encountered.</p> Source code in <code>src/signalbot/message.py</code> <pre><code>class UnknownMessageFormatError(Exception):\n    \"\"\"Exception raised when a message with an unknown format is encountered.\"\"\"\n</code></pre>"},{"location":"api_quote/","title":"Quote","text":""},{"location":"api_quote/#signalbot.quote.Quote","title":"<code>Quote</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dataclass to representing a quote.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the quoted message.</p> <code>author</code> <code>str</code> <p>The author of the quoted message.</p> <code>author_number</code> <code>str | None</code> <p>The phone number of the author of the quoted message, if available.</p> <code>author_uuid</code> <code>str</code> <p>The UUID of the author of the quoted message.</p> <code>text</code> <code>str</code> <p>The text of the quoted message.</p> <code>attachments</code> <code>list[dict[str, Any]]</code> <p>A list of attachments of the quoted message, if available.</p> Source code in <code>src/signalbot/quote.py</code> <pre><code>class Quote(BaseModel):\n    \"\"\"Dataclass to representing a quote.\n\n    Attributes:\n        id: The ID of the quoted message.\n        author: The author of the quoted message.\n        author_number: The phone number of the author of the quoted message, if\n            available.\n        author_uuid: The UUID of the author of the quoted message.\n        text: The text of the quoted message.\n        attachments: A list of attachments of the quoted message, if available.\n    \"\"\"\n\n    model_config = ConfigDict(alias_generator=to_camel)  # Support fields in camel case\n\n    id: int\n    author: str\n    author_number: str | None = None\n    author_uuid: str\n    text: str\n    attachments: list[dict[str, Any]]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The code shown here can be found the example folder.</p> <p>Bot using every example. <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom commands import (\n    AttachmentCommand,\n    DeleteCommand,\n    DeleteLocalAttachmentCommand,\n    EditCommand,\n    HelpCommand,\n    PingCommand,\n    ReceiveDeleteCommand,\n    RegexTriggeredCommand,\n    ReplyCommand,\n    StylesCommand,\n    TriggeredCommand,\n    TypingCommand,\n)\n\nfrom signalbot import SignalBot, enable_console_logging\n\n\ndef main() -&gt; None:\n    enable_console_logging(logging.INFO)\n\n    signal_service = os.environ[\"SIGNAL_SERVICE\"]\n    phone_number = os.environ[\"PHONE_NUMBER\"]\n\n    config = {\n        \"signal_service\": signal_service,\n        \"phone_number\": phone_number,\n    }\n    bot = SignalBot(config)\n\n    bot.register(HelpCommand())\n\n    # enable a chat command for all contacts and all groups\n    bot.register(PingCommand())\n    bot.register(ReplyCommand())\n\n    # enable a chat command only for groups\n    bot.register(AttachmentCommand(), contacts=False, groups=True)\n\n    # enable a chat command for one specific group with the name \"My Group\"\n    bot.register(TypingCommand(), groups=[\"My Group\"])\n\n    # chat command is enabled for all groups and one specific contact\n    bot.register(TriggeredCommand(), contacts=[\"+490123456789\"], groups=True)\n\n    bot.register(RegexTriggeredCommand())\n\n    bot.register(EditCommand())\n    bot.register(DeleteCommand())\n    bot.register(ReceiveDeleteCommand())\n    bot.register(DeleteLocalAttachmentCommand())\n    bot.register(StylesCommand())\n    bot.start()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"examples/#example-commands","title":"Example commands","text":"AttachmentCommand <pre><code>import base64\nfrom pathlib import Path\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass AttachmentCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"friday: \ud83e\udd80 Send and delete an image.\"\n\n    @triggered(\"friday\")\n    async def handle(self, c: Context) -&gt; None:\n        with open(Path(__file__).parent / \"image.jpeg\", \"rb\") as f:  # noqa: ASYNC230, PTH123\n            image = str(base64.b64encode(f.read()), encoding=\"utf-8\")\n\n        await c.send(\n            \"https://www.youtube.com/watch?v=pU2SdH1HBuk\",\n            base64_attachments=[image],\n        )\n</code></pre> DeleteCommand &amp; DeleteLocalAttachmentCommand &amp; ReceiveDeleteCommand <pre><code>import asyncio\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, MessageType, triggered\n\n\nclass DeleteCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"delete: \ud83d\uddd1\ufe0f Delete a message.\"\n\n    @triggered(\"delete\")\n    async def handle(self, c: Context) -&gt; None:\n        timestamp = await c.send(\"This message will be deleted in two seconds.\")\n        await asyncio.sleep(2)\n        await c.remote_delete(timestamp=timestamp)\n\n\nclass DeleteLocalAttachmentCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"delete_attachment: \ud83d\uddd1\ufe0f Delete the local copy of an attachment.\"\n\n    @triggered(\"delete_attachment\")\n    async def handle(self, c: Context) -&gt; None:\n        local_filenames = c.message.attachments_local_filenames\n        if local_filenames is None or len(local_filenames) == 0:\n            await c.send(\"Please send an attachment to delete.\")\n\n        for attachment_filename in local_filenames:\n            attachment_path: Path = (\n                Path.home()\n                / \".local/share/signal-api/attachments\"\n                / attachment_filename\n            )\n\n            if attachment_path.exists():\n                print(f\"Received file {attachment_path}\")  # noqa: T201\n\n            await c.bot.delete_attachment(attachment_filename)\n\n            if not attachment_path.exists():\n                print(f\"Deleted file {attachment_path}\")  # noqa: T201\n\n\nclass ReceiveDeleteCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"N/A: \ud83d\uddd1\ufe0f Receive a message has been deleted notification.\"\n\n    async def handle(self, c: Context) -&gt; None:\n        if c.message.type == MessageType.DELETE_MESSAGE:\n            deleted_at = datetime.fromtimestamp(  # noqa: DTZ006\n                c.message.remote_delete_timestamp / 1000\n            )\n            await c.send(f\"You've deleted a message, which was sent at {deleted_at}.\")\n</code></pre> EditCommand <pre><code>import asyncio\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass EditCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"edit: \u270f\ufe0f Edit a message.\"\n\n    @triggered(\"edit\")\n    async def handle(self, c: Context) -&gt; None:\n        timestamp = await c.send(\"This message will be edited in two seconds.\")\n        await asyncio.sleep(2)\n        await c.edit(\"This message has been edited.\", timestamp)\n</code></pre> HelpCommand <pre><code>from abc import abstractmethod\n\nfrom signalbot import Command, Context, triggered\n\n\nclass CommandWithHelpMessage(Command):\n    @abstractmethod\n    def help_message(self) -&gt; str:\n        pass\n\n\nclass HelpCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"help: \ud83c\udd98 Shows information about available commands.\"\n\n    @triggered(\"help\")\n    async def handle(self, c: Context) -&gt; None:\n        help_message = \"Available commands:\\n\"\n        command: CommandWithHelpMessage\n        for command, _, _, _ in self.bot.commands:\n            help_message += f\"\\t - {command.help_message()}\\n\"\n        await c.send(help_message)\n</code></pre> TriggeredCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass TriggeredCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"command_1, command_2 or command_3: \ud83d\ude24\ud83d\ude24\ud83d\ude24 Decorator example.\"\n\n    # add case_sensitive=True for case sensitive triggers\n    @triggered(\"command_1\", \"Command_2\", \"CoMmAnD_3\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"I am triggered\")\n</code></pre> PingCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass PingCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"ping: \ud83c\udfd3 Listen for a ping and send a pong reply.\"\n\n    @triggered(\"ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"pong\")\n</code></pre> RegexTriggeredCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, regex_triggered\n\n\nclass RegexTriggeredCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"^[\\\\w\\\\.-]+@gmail\\\\.com$: \ud83d\ude24 Regular expression decorator example.\"\n\n    @regex_triggered(r\"^[\\w\\.-]+@gmail\\.com$\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Detected a Gmail address!\")\n</code></pre> ReplyCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass ReplyCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"reply: \ud83d\udcac Reply to a message.\"\n\n    @triggered(\"reply\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.reply(\"This is a reply.\")\n</code></pre> StylesCommand <pre><code>from commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass StylesCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"styles: \ud83c\udfa8 Demonstrates different text styles.\"\n\n    @triggered(\"styles\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"**Bold style**\", text_mode=\"styled\")\n        await c.send(\"*Italic style*\", text_mode=\"styled\")\n        await c.send(\"~Strikethrough style~\", text_mode=\"styled\")\n        await c.send(\"||Spoiler style||\", text_mode=\"styled\")\n        await c.send(\"`Monospaced style`\", text_mode=\"styled\")\n</code></pre> TypingCommand <pre><code>import asyncio\n\nfrom commands.help import CommandWithHelpMessage\nfrom signalbot import Context, triggered\n\n\nclass TypingCommand(CommandWithHelpMessage):\n    def help_message(self) -&gt; str:\n        return \"typing: \u2328\ufe0f Demonstrates typing indicator for a few seconds.\"\n\n    @triggered(\"typing\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.start_typing()\n        seconds = 5\n        await asyncio.sleep(seconds)\n        await c.stop_typing()\n        await c.send(f\"Typed for {seconds}s\")\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>Install it with <pre><code>pip install signalbot\n</code></pre></p> <p>Below you can find a minimal example on how to use the package. Save it as <code>bot.py</code>. There is also a bigger example in the examples page.</p> <pre><code>import logging  # noqa: INP001\nimport os\n\nfrom signalbot import Command, Context, SignalBot, enable_console_logging, triggered\n\n\nclass PingCommand(Command):\n    @triggered(\"Ping\")\n    async def handle(self, c: Context) -&gt; None:\n        await c.send(\"Pong\")\n\n\nif __name__ == \"__main__\":\n    enable_console_logging(logging.INFO)\n\n    bot = SignalBot(\n        {\n            \"signal_service\": os.environ[\"SIGNAL_SERVICE\"],\n            \"phone_number\": os.environ[\"PHONE_NUMBER\"],\n        }\n    )\n    bot.register(PingCommand())  # Run the command for all contacts and groups\n    bot.start()\n</code></pre> <p>Please check out https://github.com/bbernhard/signal-cli-rest-api#getting-started to learn about signal-cli-rest-api and signal-cli. A good first step is to make the example above work.</p> <ol> <li> <p>Run signal-cli-rest-api in <code>normal</code> mode first. <pre><code>docker run -p 8080:8080 \\\n    -v $(pwd)/signal-cli-config:/home/.local/share/signal-cli \\\n    -e 'MODE=normal' bbernhard/signal-cli-rest-api:latest\n</code></pre></p> </li> <li> <p>Open http://127.0.0.1:8080/v1/qrcodelink?device_name=local to link your account with the signal-cli-rest-api server</p> </li> <li> <p>In your Signal app, open settings and scan the QR code. The server can now receive and send messages. The access key will be stored in <code>$(PWD)/signal-cli-config</code>.</p> </li> <li> <p>Restart the server in <code>json-rpc</code> mode. <pre><code>docker run -p 8080:8080 \\\n    -v $(pwd)/signal-cli-config:/home/.local/share/signal-cli \\\n    -e 'MODE=json-rpc' bbernhard/signal-cli-rest-api:latest\n</code></pre></p> </li> <li> <p>The logs should show something like this. You can also confirm that the server is running in the correct mode by visiting http://127.0.0.1:8080/v1/about. <pre><code>...\ntime=\"2022-03-07T13:02:22Z\" level=info msg=\"Found number +491234567890 and added it to jsonrpc2.yml\"\n...\ntime=\"2022-03-07T13:02:24Z\" level=info msg=\"Started Signal Messenger REST API\"\n</code></pre></p> </li> <li> <p>Install <code>signalbot</code> and start your python script. You need to pass following environment variables to make the example run:</p> </li> <li><code>SIGNAL_SERVICE</code>: Address of the signal service without protocol, e.g. <code>127.0.0.1:8080</code></li> <li><code>PHONE_NUMBER</code>: Phone number of the bot, e.g. <code>+49123456789</code></li> </ol> <pre><code>export SIGNAL_SERVICE=\"127.0.0.1:8080\"\nexport PHONE_NUMBER=\"+49123456789\"\npip install signalbot\npython bot.py\n</code></pre> <ol> <li> <p>The logs should indicate that one \"producer\" and three \"consumers\" have started. The producer checks for new messages sent to the linked account using a web socket connection. It creates a task for every registered command and the consumers work off the tasks. In case you are working with many blocking function calls, you may need to adjust the number of consumers such that the bot stays reactive. <pre><code>&lt;date&gt; signalbot [WARNING] - __init__ - [Bot] Could not initialize Redis and no SQLite DB name was given. In-memory storage will be used. Restarting will delete the storage! Add storage: {'type': 'in-memory'} to the config to silence this error.\n&lt;date&gt; signalbot [INFO] - _detect_groups - [Bot] 3 groups detected\n&lt;date&gt; signalbot [INFO] - _produce - [Bot] Producer #1 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #1 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #2 started\n&lt;date&gt; signalbot [INFO] - _consume - [Bot] Consumer #3 started\n</code></pre></p> </li> <li> <p>Send the message <code>Ping</code> (case sensitive) to the number that the bot is listening to. The bot (i.e. the linked account) should respond with a <code>Pong</code>. Confirm that the bot received a raw message, that the consumer worked on the message and that a new message has been sent. <pre><code>&lt;date&gt; signalbot [INFO] - _produce - [Raw Message] {\"envelope\": &lt;raw message dictionary&gt;}\n&lt;date&gt; signalbot [INFO] - _consume_new_item - [Bot] Consumer #2 got new job in 0.00046 seconds\n&lt;date&gt; signalbot [INFO] - _produce - [Raw Message] {\"envelope\": &lt;raw message dictionary&gt;}\n&lt;date&gt; signalbot [INFO] - send - [Bot] New message 1760797696983 sent:\nPong\n</code></pre></p> </li> </ol>"},{"location":"local_development/","title":"Contributing","text":"<p>Contributions are welcome.</p> <p>The first step to contribute is to install the package in editable mode. For any changes, check that the tests still pass as detailed below.</p>"},{"location":"local_development/#local-development","title":"Local development","text":"<ol> <li>Install uv.</li> <li>Create a venv and install signalbot with its dependencies in it     <pre><code>uv sync\n</code></pre></li> <li>Install the prek hook for linting and formatting     <pre><code>uv run prek install\n</code></pre></li> </ol>"},{"location":"local_development/#unit-testing","title":"Unit Testing","text":"<p>The tests can be executed with</p> <pre><code>uv run pytest\n</code></pre> <p>In many cases, we can mock receiving and sending messages to speed up development time. To do so, you can use <code>signalbot.utils.ChatTestCase</code> which sets up a \"skeleton\" bot. Then, you can send messages using the <code>@mock_chat</code> decorator in <code>signalbot.utils</code>. You can find an example implementation in <code>tests/test_chat.py</code>.</p>"},{"location":"local_development/#serving-the-documentation-locally","title":"Serving the documentation locally","text":"<ol> <li>Install the docs dependencies     <pre><code>uv sync --group docs\n</code></pre></li> <li>Run the mkdocs serve command     <pre><code>uv run mkdocs serve --livereload --watch ./\n</code></pre></li> </ol>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li>Check that you linked your account successfully</li> <li>Can you receive messages using <code>wscat</code> (websockets) and send messages using <code>curl</code> (http)?</li> <li>Do you see incoming messages in the API logs?</li> <li>Do you see the \"raw\" messages in the bot's logs?</li> <li>Do you see \"consumers\" picking up jobs and handling incoming messages?</li> <li>Do you see the response in the bot's logs?</li> </ul>"}]}